import type { AssetsClassification, InteractionMetrics, InteractionType } from '../common';

let config: Config | undefined;
export interface AdditionalData {
	[key: string]:
		| null
		| string
		| number
		| boolean
		| undefined
		| AdditionalData
		| Record<string, AdditionalData>
		| Array<AdditionalData>;
}

export interface SSRTiming {
	label: string;
	data: {
		startTime: number;
		duration: number;
	};
}

type Capability = 'feature_flag_access' | 'react_profiler';
type InteractionKind = 'page_load' | 'transition' | 'press' | 'typing' | 'legacy' | 'hover';
type UFONameOverride = {
	readonly [ufoName: string]: {
		readonly [metricKey: string]: string;
	};
};
type ResourceType = 'script' | 'link' | 'fetch' | 'xmlhttprequest';

type SelectorConfig = {
	id: boolean;
	testId: boolean;
	role: boolean;
	className: boolean;
	dataVC?: boolean;
};

type Rates = {
	readonly [key: string]: number;
};

// Defensively typed, since this is directly user-editable
// and they could delete empty members
export type Config = {
	readonly enabled?: boolean;
	readonly doNotAbortActivePressInteraction?: string[];
	readonly doNotAbortActivePressInteractionOnTransition?: string[];
	readonly awaitBM3TTI?: string[];
	readonly ufoNameOverrides?: UFONameOverride;
	readonly namePrefix?: string;
	readonly segmentPrefix?: string;
	readonly rates?: Rates;
	readonly rules?: readonly {
		readonly test?: string;
		readonly rate?: number;
	}[];
	readonly killswitch?: readonly string[];
	readonly killswitchNestedSegments?: boolean;
	readonly typingMethod?: string;
	readonly capability?: Record<Capability, number>;
	readonly kind?: Record<InteractionKind, number>;
	readonly allowedResources?: Array<ResourceType>;
	readonly allowedResourcesParams?: Array<string>;
	readonly autoGeneratedRate?: number;
	readonly removePageSegmentsUFOPrefixes?: boolean;
	readonly removeInteractionsUFOPrefixes?: boolean;
	readonly product: string;
	readonly region: string;
	readonly additionalPayloadData?: (interaction: InteractionMetrics) => AdditionalData;
	readonly ssr?: {
		readonly getSSRTimings?: () => SSRTiming[];
		readonly getSSRDoneTime?: () => number | undefined;
	};
	readonly assetsClassification?: AssetsClassification;
	readonly enableBetterPageVisibilityApi?: boolean;
	readonly vc?: {
		readonly enabled?: boolean;
		readonly heatmapSize?: number;
		readonly oldDomUpdates?: boolean;
		readonly devToolsEnabled?: boolean;
		readonly selectorConfig?: SelectorConfig;
		readonly ssr?: boolean;
		readonly ssrWhitelist?: string[];
		readonly stopVCAtInteractionFinish?: boolean;
	};
	readonly postInteractionLog?: {
		readonly enabled?: boolean;
		readonly rates?: Rates;
		readonly kind?: Record<InteractionType, number>;
	};
	readonly experimentalInteractionMetrics?: {
		readonly enabled?: boolean;
		readonly rates?: Rates;
		readonly kind?: Record<InteractionType, number>;
	};
	readonly enableSegmentHighlighting?: boolean;
	readonly enableAdditionalPerformanceMarks?: boolean;
	readonly shouldCalculateLighthouseMetricsFromTTAI?: boolean;
	readonly timeWindowForLateMutationsInMilliseconds?: number;
	readonly manuallyTrackReactProfilerMounts?: boolean;
	readonly enableEditorLnvHandler?: boolean;
	/**
	 * @deprecated setting this will do nothing now
	 */
	readonly enableCompleteUsingDoubleRAF?: boolean;
};

export function setUFOConfig(newConfig: Config) {
	config = newConfig;
}

export function getConfig() {
	return config;
}

export function getInteractionRate(name: string, interactionKind: InteractionKind): number {
	try {
		if (!config) {
			return 0;
		}
		const { killswitch, rates, rules, kind, autoGeneratedRate } = config;

		if (killswitch != null) {
			// Specifically kill certain events
			if (killswitch.includes(name)) {
				return 0;
			}
		}

		if (rates != null) {
			// Decide the rate explicitly
			if (rates[name] != null) {
				return rates[name];
			}
		}

		if (rules != null) {
			for (let i = 0; i < rules.length; i++) {
				const rule = rules[i];
				const { test, rate } = rule;
				if (test != null && rate != null) {
					const regexp = new RegExp(test, 'ig');

					if (regexp.test(name)) {
						return rate;
					}
				}
			}
		}

		const isAutogenerated = name?.startsWith('auto-generated');
		if (isAutogenerated) {
			const rate = autoGeneratedRate;
			if (rate != null) {
				return rate;
			}
		}

		if (kind != null) {
			const rate = kind[interactionKind];
			if (rate != null) {
				return rate;
			}
		}

		return 0;
	} catch (e: any) {
		// Fallback
		return 0;
	}
}

export function getExperimentalInteractionRate(
	name: string,
	interactionType: InteractionType,
): number {
	try {
		if (!config) {
			return 0;
		}
		const { experimentalInteractionMetrics } = config;
		if (!experimentalInteractionMetrics?.enabled) {
			return 0;
		}

		if (
			experimentalInteractionMetrics.rates &&
			typeof experimentalInteractionMetrics.rates[name] === 'number'
		) {
			return experimentalInteractionMetrics.rates[name];
		}

		if (
			experimentalInteractionMetrics.kind &&
			typeof experimentalInteractionMetrics.kind[interactionType] === 'number'
		) {
			return experimentalInteractionMetrics.kind[interactionType];
		}

		return 0;
	} catch (e: any) {
		return 0;
	}
}

export function getPostInteractionRate(name: string, interactionType: InteractionType): number {
	try {
		if (!config) {
			return 0;
		}
		const { postInteractionLog } = config;
		if (!postInteractionLog?.enabled) {
			return 0;
		}

		if (postInteractionLog.rates && typeof postInteractionLog.rates[name] === 'number') {
			return postInteractionLog.rates[name];
		}

		if (postInteractionLog.kind && typeof postInteractionLog.kind[interactionType] === 'number') {
			return postInteractionLog.kind[interactionType];
		}

		return 0;
	} catch (e: any) {
		return 0;
	}
}

export function getCapabilityRate(capability: Capability): number {
	try {
		if (!config) {
			return 0;
		}
		const { capability: capabilityRate } = config;
		if (capabilityRate != null) {
			const rate = capabilityRate[capability];
			if (rate != null) {
				return rate;
			}
		}
		return 0;
	} catch {
		return 0;
	}
}

const validTypingMethods = ['timeout', 'timeoutNoAlloc', 'mutationObserver'] as const;
type ValidTypingMethod = (typeof validTypingMethods)[number];

export function getTypingPerformanceTracingMethod(): ValidTypingMethod {
	const defaultMethod = 'timeout';
	try {
		if (!config) {
			return defaultMethod;
		}
		const { typingMethod } = config;

		if (typingMethod != null && validTypingMethods.find((m) => m === typingMethod)) {
			return typingMethod as ValidTypingMethod;
		} else {
			return defaultMethod;
		}
	} catch (e: any) {
		return defaultMethod;
	}
}

// Will ask UFO to wait for BM3 TTI for all events on this list
export function getAwaitBM3TTIList(): string[] {
	try {
		if (!config) {
			return [];
		}
		const { awaitBM3TTI } = config;

		if (awaitBM3TTI != null) {
			return awaitBM3TTI;
		} else {
			return [];
		}
	} catch (e: any) {
		return [];
	}
}

// Flag to remove ufo segments prefixes
export function getRemovePageSegmentsUFOPrefixes(): boolean {
	try {
		if (!config) {
			return false;
		}
		const { removePageSegmentsUFOPrefixes } = config;

		if (removePageSegmentsUFOPrefixes != null) {
			return removePageSegmentsUFOPrefixes;
		} else {
			return false;
		}
	} catch (e: any) {
		return false;
	}
}

// Flag to remove ufo segments prefixes
export function getRemoveInteractionsUFOPrefixes(): boolean {
	try {
		if (!config) {
			return false;
		}
		const { removeInteractionsUFOPrefixes } = config;

		if (removeInteractionsUFOPrefixes != null) {
			return removeInteractionsUFOPrefixes;
		} else {
			return false;
		}
	} catch (e: any) {
		return false;
	}
}

// Will ask UFO to override ufoName => experienceKey to the apdex key
// This is to cover use cases where one rUFO route is split into multiple BM3 keys (1:N)
// This workaround should only be used as last resource,
// when we find router limitations preventing teams from splliting these routes
export function getUfoNameOverrides(): UFONameOverride | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { ufoNameOverrides } = config;
		if (ufoNameOverrides != null) {
			return ufoNameOverrides;
		}
		return undefined;
	} catch (e: any) {
		return undefined;
	}
}

// Contains the list of interactions that do not abort existing known interactions
export function getDoNotAbortActivePressInteraction(): string[] | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { doNotAbortActivePressInteraction } = config;

		return doNotAbortActivePressInteraction;
	} catch (e: any) {
		return undefined;
	}
}

// Contains the list of interactions that do not abort on transitions
export function getDoNotAbortActivePressInteractionOnTransition(): string[] | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { doNotAbortActivePressInteractionOnTransition } = config;

		return doNotAbortActivePressInteractionOnTransition;
	} catch (e: any) {
		return undefined;
	}
}

export function shouldHandleEditorLnv(): boolean {
	try {
		return config?.enableEditorLnvHandler ?? false;
	} catch (e: any) {
		return false;
	}
}
