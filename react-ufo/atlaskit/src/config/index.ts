import { fg } from '@atlaskit/platform-feature-flags';

import type { AssetsConfig, InteractionMetrics, InteractionType } from '../common';

let config: Config | undefined;
export interface AdditionalData {
	[key: string]:
		| null
		| string
		| number
		| boolean
		| undefined
		| AdditionalData
		| Record<string, AdditionalData>
		| Array<AdditionalData>;
}

export interface SSRTiming {
	label: string;
	data: {
		startTime: number;
		duration: number;
	};
}

type Capability = 'feature_flag_access' | 'react_profiler';
type InteractionKind = 'page_load' | 'transition' | 'press' | 'typing' | 'legacy' | 'hover';
type UFONameOverride = {
	readonly [ufoName: string]: {
		readonly [metricKey: string]: string;
	};
};
type ResourceType = 'script' | 'link' | 'fetch' | 'xmlhttprequest';

type SelectorConfig = {
	id: boolean;
	testId: boolean;
	role: boolean;
	className: boolean;
	dataVC?: boolean;
};

type SegmentThreshold = {
	readonly [key: string]: number;
};

type Rates = {
	readonly [key: string]: number;
};

export type TTVCRevision = 'fy25.01' | 'fy25.02' | 'fy25.03';
export const DEFAULT_TTVC_REVISION = 'fy25.03';

// Defensively typed, since this is directly user-editable
// and they could delete empty members
export type Config = {
	readonly enabled?: boolean;
	readonly interactionTimeout?: Record<string, number>;
	readonly doNotAbortActivePressInteraction?: string[];
	readonly doNotAbortActivePressInteractionOnTransition?: string[];
	readonly awaitBM3TTI?: string[];
	readonly ufoNameOverrides?: UFONameOverride;
	readonly namePrefix?: string;
	readonly segmentPrefix?: string;
	readonly rates?: Rates;
	readonly rules?: readonly {
		readonly test?: string;
		readonly rate?: number;
	}[];
	readonly killswitch?: readonly string[];
	/**
	 * @private
	 * @deprecated - remove on FG cleanup of platform_ufo_remove_deprecated_config_fields
	 */
	readonly killswitchNestedSegments?: boolean;
	readonly typingMethod?: string;
	/**
	 * @private
	 * @deprecated - remove on FG cleanup of platform_ufo_remove_deprecated_config_fields
	 */
	readonly capability?: Record<Capability, number>;
	readonly kind?: Record<InteractionKind, number>;
	readonly allowedResources?: Array<ResourceType>;
	readonly allowedResourcesParams?: Array<string>;
	readonly autoGeneratedRate?: number;
	readonly product: string;
	readonly region: string;
	readonly additionalPayloadData?: (interaction: InteractionMetrics) => AdditionalData;
	readonly ssr?: {
		readonly getSSRTimings?: () => SSRTiming[];
		readonly getSSRDoneTime?: () => number | undefined;
	};
	readonly assetsConfig?: AssetsConfig;
	readonly enableBetterPageVisibilityApi?: boolean;
	readonly segmentsThreshold?: SegmentThreshold;
	readonly vc?: {
		readonly enabled?: boolean;
		readonly heatmapSize?: number;
		readonly oldDomUpdates?: boolean;
		readonly devToolsEnabled?: boolean;
		readonly selectorConfig?: SelectorConfig;
		readonly ssr?: boolean;
		readonly ssrWhitelist?: string[];
		readonly ssrEnablePageLayoutPlaceholder?: boolean;
		readonly includeSSRInV3?: boolean;
		readonly stopVCAtInteractionFinish?: boolean;
		readonly includeSSRRatio?: boolean;
		/**
		 * The revisions of TTVC that will be calculated
		 * - `all` is the TTVC revisions that are used on a product level
		 * - `byExperience` is the version that is used on an experience level.
		 *   Note that an entry in the `byExperience` config should only be a SUBSET of the `all` config,
		 *   i.e. every element for all `byExperience` entry configs should exist in the `all` config
		 */
		readonly enabledVCRevisions?: {
			all: readonly TTVCRevision[];
			byExperience?: Record<string, readonly TTVCRevision[]>;
		};
	};
	readonly postInteractionLog?: {
		readonly enabled?: boolean;
		readonly rates?: Rates;
		readonly kind?: Record<InteractionType, number>;
	};
	readonly experimentalInteractionMetrics?: {
		readonly enabled?: boolean;
		readonly rates?: Rates;
		readonly kind?: Record<InteractionType, number>;
	};
	readonly enableSegmentHighlighting?: boolean;
	readonly enableAdditionalPerformanceMarks?: boolean;
	/**
	 * @private
	 * @deprecated - remove on FG cleanup of platform_ufo_remove_deprecated_config_fields
	 */
	readonly shouldCalculateLighthouseMetricsFromTTAI?: boolean;
	readonly timeWindowForLateMutationsInMilliseconds?: number;
	readonly manuallyTrackReactProfilerMounts?: boolean;
};

export function setUFOConfig(newConfig: Config) {
	// Handle edge cases with `enabledVCRevisions`
	const { enabledVCRevisions } = newConfig?.vc ?? {};
	if (typeof enabledVCRevisions?.byExperience === 'object') {
		config = {
			...newConfig,
			vc: {
				...newConfig.vc,
				enabledVCRevisions: {
					// enforce axiom about `enabledVCRevisions.all` config
					all: Array.from(
						new Set([
							DEFAULT_TTVC_REVISION,
							...enabledVCRevisions?.all,
							...Object.values(enabledVCRevisions?.byExperience).flat(),
						]),
					),
					byExperience: { ...enabledVCRevisions?.byExperience },
				},
			},
		};
	} else {
		config = newConfig;
	}
}

export function getConfig() {
	return config;
}

const isValidConfigArray = <T>(array: any): array is T[] => {
	return Array.isArray(array) && array.length > 0;
};

export function getEnabledVCRevisions(experienceKey: string = ''): readonly TTVCRevision[] {
	try {
		if (!config) {
			return [];
		}

		if (config.vc?.enabled) {
			const { enabledVCRevisions } = config.vc ?? {};

			if (isValidConfigArray(enabledVCRevisions?.byExperience?.[experienceKey])) {
				return enabledVCRevisions.byExperience?.[experienceKey];
			}

			if (isValidConfigArray(enabledVCRevisions?.all)) {
				return enabledVCRevisions.all;
			}

			return [DEFAULT_TTVC_REVISION];
		}

		return [];
	} catch {
		return [];
	}
}

export function isVCRevisionEnabled(revision: TTVCRevision, experienceKey?: string) {
	return getEnabledVCRevisions(experienceKey).includes(revision);
}

export function getMostRecentVCRevision(experienceKey: string = '') {
	const enabledVCRevisions = getEnabledVCRevisions(experienceKey);

	return enabledVCRevisions[enabledVCRevisions.length - 1];
}

export function getInteractionRate(name: string, interactionKind: InteractionKind): number {
	try {
		if (!config) {
			return 0;
		}
		const { killswitch, rates, rules, kind, autoGeneratedRate } = config;

		if (killswitch != null) {
			// Specifically kill certain events
			if (killswitch.includes(name)) {
				return 0;
			}
		}

		if (rates != null) {
			// Decide the rate explicitly
			if (rates[name] != null) {
				return rates[name];
			}
		}

		if (rules != null) {
			for (let i = 0; i < rules.length; i++) {
				const rule = rules[i];
				const { test, rate } = rule;
				if (test != null && rate != null) {
					const regexp = new RegExp(test, 'ig');

					if (regexp.test(name)) {
						return rate;
					}
				}
			}
		}

		const isAutogenerated = name?.startsWith('auto-generated');
		if (isAutogenerated) {
			const rate = autoGeneratedRate;
			if (rate != null) {
				return rate;
			}
		}

		if (kind != null) {
			const rate = kind[interactionKind];
			if (rate != null) {
				return rate;
			}
		}

		return 0;
	} catch (e: any) {
		// Fallback
		return 0;
	}
}

export function getExperimentalInteractionRate(
	name: string,
	interactionType: InteractionType,
): number {
	try {
		if (!config) {
			return 0;
		}
		const { experimentalInteractionMetrics } = config;
		if (!experimentalInteractionMetrics?.enabled) {
			return 0;
		}

		if (
			experimentalInteractionMetrics.rates &&
			typeof experimentalInteractionMetrics.rates[name] === 'number'
		) {
			return experimentalInteractionMetrics.rates[name];
		}

		if (
			experimentalInteractionMetrics.kind &&
			typeof experimentalInteractionMetrics.kind[interactionType] === 'number'
		) {
			return experimentalInteractionMetrics.kind[interactionType];
		}

		return 0;
	} catch (e: any) {
		return 0;
	}
}

export function getPostInteractionRate(name: string, interactionType: InteractionType): number {
	try {
		if (!config) {
			return 0;
		}
		const { postInteractionLog } = config;
		if (!postInteractionLog?.enabled) {
			return 0;
		}

		if (interactionType !== 'page_load' && interactionType !== 'transition') {
			return 0;
		}

		if (postInteractionLog.rates && typeof postInteractionLog.rates[name] === 'number') {
			return postInteractionLog.rates[name];
		}

		if (postInteractionLog.kind && typeof postInteractionLog.kind[interactionType] === 'number') {
			return postInteractionLog.kind[interactionType];
		}

		return 0;
	} catch (e: any) {
		return 0;
	}
}

export function getCapabilityRate(capability: Capability): number {
	if (fg('platform_ufo_remove_deprecated_config_fields')) {
		return 1;
	}

	try {
		if (!config) {
			return 0;
		}
		const { capability: capabilityRate } = config;
		if (capabilityRate != null) {
			const rate = capabilityRate[capability];
			if (rate != null) {
				return rate;
			}
		}
		return 0;
	} catch {
		return 0;
	}
}

const validTypingMethods = ['timeout', 'timeoutNoAlloc', 'mutationObserver'] as const;
type ValidTypingMethod = (typeof validTypingMethods)[number];

export function getTypingPerformanceTracingMethod(): ValidTypingMethod {
	const defaultMethod = 'timeout';
	try {
		if (!config) {
			return defaultMethod;
		}
		const { typingMethod } = config;

		if (typingMethod != null && validTypingMethods.find((m) => m === typingMethod)) {
			return typingMethod as ValidTypingMethod;
		} else {
			return defaultMethod;
		}
	} catch (e: any) {
		return defaultMethod;
	}
}

// Will ask UFO to wait for BM3 TTI for all events on this list
export function getAwaitBM3TTIList(): string[] {
	try {
		if (!config) {
			return [];
		}
		const { awaitBM3TTI } = config;

		if (awaitBM3TTI != null) {
			return awaitBM3TTI;
		} else {
			return [];
		}
	} catch (e: any) {
		return [];
	}
}

// Will ask UFO to override ufoName => experienceKey to the apdex key
// This is to cover use cases where one rUFO route is split into multiple BM3 keys (1:N)
// This workaround should only be used as last resource,
// when we find router limitations preventing teams from splliting these routes
export function getUfoNameOverrides(): UFONameOverride | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { ufoNameOverrides } = config;
		if (ufoNameOverrides != null) {
			return ufoNameOverrides;
		}
		return undefined;
	} catch (e: any) {
		return undefined;
	}
}

// Contains the list of interactions that do not abort existing known interactions
export function getDoNotAbortActivePressInteraction(): string[] | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { doNotAbortActivePressInteraction } = config;

		return doNotAbortActivePressInteraction;
	} catch (e: any) {
		return undefined;
	}
}

// Contains the list of interactions that do not abort on transitions
export function getDoNotAbortActivePressInteractionOnTransition(): string[] | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { doNotAbortActivePressInteractionOnTransition } = config;

		return doNotAbortActivePressInteractionOnTransition;
	} catch (e: any) {
		return undefined;
	}
}

export const CLEANUP_TIMEOUT = 60 * 1000;
export function getInteractionTimeout(ufoName: string): number {
	try {
		if (!config) {
			return CLEANUP_TIMEOUT;
		}
		const { interactionTimeout } = config;

		if (interactionTimeout != null && interactionTimeout[ufoName] != null) {
			return interactionTimeout[ufoName];
		}
		if (interactionTimeout != null && interactionTimeout.__globalInteractionTimeout != null) {
			return interactionTimeout.__globalInteractionTimeout;
		} else {
			return CLEANUP_TIMEOUT;
		}
	} catch (e: any) {
		return CLEANUP_TIMEOUT;
	}
}
