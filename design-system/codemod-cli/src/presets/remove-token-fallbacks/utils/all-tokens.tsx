import {
	legacyLightTokens as legacyLightTheme,
	light as lightTheme,
	shape as shapeTheme,
	spacing as spacingTheme,
	typographyAdg3 as typographyAdg3Theme,
} from '@atlaskit/tokens/tokens-raw';

const typographyGroups = ['typography', 'fontWeight', 'fontFamily'];

type Token = {
	cleanName: string;
	value: any;
};

function buildCombinedMap(...arrays: Token[][]): Record<string, string> {
	const combinedMap: Record<string, string> = {};
	arrays.forEach((array) => {
		array.forEach((token) => {
			combinedMap[token.cleanName] = token.value.toString();
		});
	});
	return combinedMap;
}

// Filter the typography tokens based on predefined groups and exclusions
const typographyAdg3ThemeFiltered = typographyAdg3Theme
	.filter((token) => typographyGroups.includes(token.attributes.group))
	.filter((token) => token.cleanName !== 'font.body.UNSAFE_small');

// Cache array: [0] for light theme, [1] for legacy light theme
const tokenMapCache: (Record<string, string> | null)[] = [null, null];

// Function to get the token map with the desired theme.
// This should be used with the same value as the @atlaskit/tokens/babel-plugin is cofigured with for the given path.
// When there is no theme, the babel plugin would use the given theme to provide default token fallbacks. Therefore it's safe to remove fallbacks only when they match the fallbacks that would be generated by the babel plugin with the given theme.
// The default value is set to use the Light theme to match the behavior of the babel plugin (packages/design-system/tokens/src/babel-plugin/plugin.tsx).
export function getTokenMap(useLegacyTheme: boolean = false): Record<string, string> {
	const themeIndex = useLegacyTheme ? 1 : 0;

	if (!tokenMapCache[themeIndex]) {
		const selectedTheme = useLegacyTheme ? legacyLightTheme : lightTheme;
		tokenMapCache[themeIndex] = buildCombinedMap(
			selectedTheme,
			spacingTheme,
			shapeTheme,
			typographyAdg3ThemeFiltered,
		);
	}

	return tokenMapCache[themeIndex]!;
}
