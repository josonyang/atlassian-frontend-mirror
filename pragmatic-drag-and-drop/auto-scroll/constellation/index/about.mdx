---
order: 0
title: Auto scroll
description: An optional package enables ergonomic automatic scrolling during a drag operation
---

import OverElementExample from '../../examples/over-element';

This package improves the browsers built in automatic scrolling during drag operations.

<Example Component={OverElementExample} appearance="showcase-only" />

## Registering auto scrolling for scrollable elements

Elements that are _registered_ for auto scrolling will be scrolled as a user drags close to the edges of the element.

```ts
import { autoScrollForElements } from '@atlaskit/pragmatic-drag-and-drop-auto-scroll/element';
import { autoScrollForFiles } from '@atlaskit/pragmatic-drag-and-drop-auto-scroll/file';

// enable better auto scrolling
const cleanup = autoScrollForElements({
  element: myScrollableElement,
});

// disable better auto scrolling
cleanup();
```

A slightly fuller example of a `react` list that is a _drop target_, and has auto scrolling

```tsx
import { useRef, ReactElement } from 'react';
import { dropTargetForElements } from '@atlaskit/pragmatic-drag-and-drop/adapter/element';
import { autoScrollForElements } from '@atlaskit/pragmatic-drag-and-drop-auto-scroll/element';
import { combine } from '@atlaskit/pragmatic-drag-and-drop/util/combine';
import invariant from 'tiny-invariant';

function ScrollableList({ children }: { children: ReactElement }) {
  const ref = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    const element = ref.current;
    invariant(element, 'Element ref not set');

    return combine(
      dropTargetForElements({
        element,
      }),
      // A scrollable element does not need to be a drop target,
      // but in this case it is.
      // We can add auto scrolling to an element along side our other
      // Pragmatic drag and drop bindings
      autoScrollForElements({
        element,
      }),
    );
  });

  return (
    <div ref={ref} style={{ overflowY: 'scroll' }}>
      {children}
    </div>
  );
}
```

### Element scrolling rules and behaviour

- You can position and style your scrollable elements however you like.
- Your scroll containers can have as many levels of nesting as you like.
- You have to register an element (eg with `autoScrollForElements`) to enable auto scrolling (otherwise the default auto scrolling will apply).
- A _registered_ scrollable element does not need to be drop target.
- Auto scrolling is registered for particular entity types. For example, `autoScrollForElements` is a drop target for elements, and `autoScrollForFiles` is a drop target for files.
- During a drag operation, you can:
  - Register new scrollable elements
  - Unregister scrollable elements
  - Change the styling, layout or dimensions of any scrollable element

## `autoScrollFor*` arguments

- `element`: the `HTMLElement` you want to add auto scrolling too. The `element` does not need to be a drop target. The `element` is the unique key for an auto scrolling registration.
- _(optional)_: `canScroll: (args: ElementGetFeedbackArgs) => boolean`: whether or not auto scrolling should occur. Disabling auto scrolling with `canScroll` will _not_ prevent the browsers built in auto scrolling, or manual user scrolling during a drag. Unfortunately, there is no way to opt out of the platforms built in auto scrolling. We included `canScroll` because it is helpful to disable this package's auto scrolling, as it is much easier for users to trigger than the platforms built in auto scrolling.

`canScroll` is a helpful way to only enable auto scrolling for particular entity types.

```tsx
autoScrollForElements({
  element: myElement,
  // only enable auto scrolling when a Card is being dragged
  canScroll: ({ source }) => source.data.type === 'card',
}),
```

```ts
export type ElementGetFeedbackArgs = {
  /**
   * The users _current_ input
   */
  input: Input;
  /**
   * The data associated with the entity being dragged
   */
  source: DragType['payload'];
  /**
   * The element trying to be scrolled
   */
  element: Element;
};
```

## Registering auto scrolling for the `window`

```ts
import { autoScrollWindowForElements } from '@atlaskit/pragmatic-drag-and-drop-auto-scroll/element';
import { autoScrollWindowForFiles } from '@atlaskit/pragmatic-drag-and-drop-auto-scroll/file';

// enable better auto scrolling on the window during drag operations
const cleanup = autoScrollWindowForElements();

// disable better auto scrolling on the window
cleanup();
```

A slightly fuller example of a `react` board that has window auto scrolling

```tsx
import { useRef, ReactElement } from 'react';
import { autoScrollForElements } from '@atlaskit/pragmatic-drag-and-drop-auto-scroll/element';
import invariant from 'tiny-invariant';

function Board({ children }: { children: ReactElement }) {
  useEffect(() => {
    return autoScrollWindowForElements();
  });

  return <div className="board">{children}</div>;
}
```

### Window auto scrolling rules and behaviour

- You have to register window auto scrolling (eg with `autoScrollWindowForElements`) to enable auto scrolling (otherwise the default auto scrolling will apply).
- Auto scrolling is registered for particular entity types. For example, `autoScrollWindowForElements` will do auto scrolling when an element is being dragged, and `autoScrollWindowForFiles` will do auto scrolling when a file is being dragged.
- You can have multiple registrations for `window` auto scrolling, but only one registration will be needed for `window` auto scrolling to occur.
- If there are no active registrations for `window` auto scrolling, then no `window` auto scrolling will occur (except for the built in one).
- During a drag operation:
  - You can register or unregister window auto scrolling
  - You can change the content of the `document` so that the `window` grows or shrinks

## `autoScrollWindowFor*` arguments

- _(optional)_: `canScroll: (args: WindowGetFeedbackArgs) => boolean`: whether or not auto scrolling should occur. Disabling auto scrolling with `canScroll` will _not_ prevent the browsers built in auto scrolling, or manual user scrolling during a drag. Unfortunately, there is no way to opt out of the platforms built in auto scrolling. We included `canScroll` because it is helpful to disable this packages auto scrolling, as it is much easier for users to trigger than the platforms built in auto scrolling.

`canScroll` is a helpful way to only enable auto scrolling for particular entity types.

```tsx
autoScrollWindowForElements({
  // only enable auto scrolling when a Card is being dragged
  canScroll: ({ source }) => source.data.type === 'card',
}),
```

```ts
export type ElementGetFeedbackArgs = {
  /**
   * The users _current_ input
   */
  input: Input;
  /**
   * The data associated with the entity being dragged
   */
  source: DragType['payload'];
};
```

## Scroll speed

There are two factors that control how fast the auto scroll speed will be:

1. **Distance**: the closer a user's pointer is to the edge of a scrollable entity (element or window), the faster the scroll will be. Scrolling will start a small distance away from an edge (based on the dimensions of the element as well as some upper thresholds). The max scroll speed will be reached at a small distance away from the edge so that a user does not need to drag exactly over the edge to have the max scroll speed.
2. **Time**: The longer a user drags over a scrollable entity, the faster the scroll speed will be (up to a limit). The result of this is that user will not start a drag, or enter into a new scrollable entity and immediately lose context due to a fast scroll speed. Time dampening starts from when an entity is being dragged over, regardless of whether the user is over an area of the entity that would trigger auto scrolling.

Time dampening is reset when:

- A scrollable entity is unregistered for more than one frame
- A scrollable entity is no longer being dragged over (except for the `window` - see below)
- A drag operation is finished

The `window` time dampening timer does not reset if leaving the `window`. Currently no `onDragLeaveWindow` and `onDragEnterWindow` events are published by Pragmatic drag and drop. If we did publish those events, then we _could_ reset the auto scrolling acceleration timer for the `window` when entering the `window`.

This package will adjust the scroll speed based on the current frame rate of the device. This is to help provide a great feeling experience across devices.

- For devices running at higher `60fps`: we pull the max scroll speed per frame down to ensure the scroll does not get too fast.
- For devices running at slower than `60fps`: we slow the scroll speed down, so that the max scroll change in a frame is what it would be if the device was running at `60fps`. This will result in a slower scroll speed in order to avoid having the scroll stutter and jump in big chunks.
- The max scroll speed is updated dynamically based on the current frame rate.

## Scroll bubbling

In order to match the browser as closely as possible, as well as to provide an experience that feels great, we have landed on the following algorithm for scrolling:

- Only scroll scrollable entities that the user is currently dragging over with their pointer.
- We scroll the inner most scrollable entity first, and then work upwards. This is known as _bubble ordering_ and it is the same order that Pragmatic drag and drop events flow.
- Only scroll one scrollable entity per axis (vertical / horizontal) in a frame. In order for a scrollable entity to be scrolled on an axis, it needs to have some available scroll in the applicable direction (forwards / backwards).

### Bubbling examples

For these examples, we have two elements that are both scrollable: `child` and `parent`

```html
<div id="parent">
  <div id="child">
    <!-- content -->
  </div>
</div>
```

**Scenario:**
Based on hitboxes, both `child` and `parent` could be scrolled forwards vertically and horizontally
`child` and `parent` both have available scroll vertically and horizontally.

- `child` is scrolled forwards vertically and horizontally
- `parent` is not scrolled

**Scenario:**
Based on hitboxes, both `child` and `parent` could be scrolled forwards vertically and horizontally
`child` has no available scroll vertically, but has scroll available horizontally
`parent` has available scroll vertically and horizontally

- `child` is scrolled horizontally (`child` has no available scroll vertically)
- `parent` is scrolled vertically (`child` has already been scrolled horizontally so `parent` can only be scrolled vertically)

## Deferred loading

This package supports being loaded in asyncronously, and can be loaded even after a drag has started.

```ts
const { autoScrollForElements } = await import(
  '@atlaskit/pragmatic-drag-and-drop-auto-scroll/element'
);
```

See our [deferred loading guide](../../improving-performance/deferred-loading) for more information.

## Axis locking

Browsers have built in auto scrolling during a drag operation. Unfortunately, this auto scrolling does not work super well. The browser's built in auto scroller cannot be disabled. This package works with the built in auto scroller to provide an experience that feels fantastic.

Because we cannot opt out of the browser's auto scrolling, we cannot provide axis locking functionality (where auto scrolling would only occur horizontally or vertically). You can achieve 'axis locking' by changing a scroll container so that it can only be scrolled in one direction; and you can make that change when a drag is occurring if you'd like.

## Declarative vs automatic scrollable entity registration

This package works by declaratively registering scrollable entities. An alternative would be to automatically apply auto scrolling to everything that is scrollable during a drag.

We chose declarative registrations for a few reasons:

- Declarative registrations allow for per item configuration (for example, adjusting the speed and auto scroll hitboxes for specific entities).
- If we find (or make) a way to disable the browser's built in auto scrolling, we can easily add functionality like `canScroll` and axis locking to the existing API.
- Declarative registrations align with the existing declarative Pragmatic drag and drop API.
