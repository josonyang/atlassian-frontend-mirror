<!-- API Report Version: 2.3 -->

## API Report File for "@atlaskit/jql-ast"

> Do not edit this file. This report is auto-generated using
> [API Extractor](https://api-extractor.com/).
> [Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

### Table of contents

- [Main Entry Types](#main-entry-types)
- [Peer Dependencies](#peer-dependencies)

### Main Entry Types

<!--SECTION START: Main Entry Types-->

```ts
import { ANTLRErrorStrategy } from 'antlr4ts';
import { ParserErrorListener } from 'antlr4ts';

// @public (undocumented)
export abstract class AbstractJastVisitor<Result> implements JastVisitor<Result> {
	protected aggregateResult(aggregate: Result, nextResult: Result): Result;
	protected abstract defaultResult(): Result;
	protected shouldVisitNextChild(node: AstNode, currentResult: Result): boolean;
	visit(node: AstNode): Result;
	visitChildren(node: AstNode): Result;
}

// @public (undocumented)
export const AFFECTED_VERSION_FIELD = 'affectedversion';

// @public (undocumented)
export const APPROVALS_FIELD = 'approvals';

// @public
export interface Argument extends AstNode {
	text: string;
	value: string;
}

// @public (undocumented)
export const ASSIGNEE_FIELD = 'assignee';

// @public (undocumented)
export const ASSIGNEE_PROPERTY = 'assignee.property';

// @public
export interface AstNode<Parent extends AstNode = AstNode<any>> {
	accept: <Result>(visitor: JastVisitor<Result>) => Result;
	enterNode: (listener: JastListener) => void;
	exitNode: (listener: JastListener) => void;
	getChildren: () => AstNode[];
	parent: Parent | null;
	position: Position | null;
}

// @public (undocumented)
export interface BaseOperator<T> extends AstNode {
	text: string;
	value: T;
}

// @public (undocumented)
export const CATEGORY_FIELD = 'category';

// @public (undocumented)
export const CHANGED_OPERATORS: readonly ['changed'];

// @public (undocumented)
export type ChangedOperator = BaseOperator<ChangedOperatorValue>;

// @public (undocumented)
export type ChangedOperatorValue = (typeof CHANGED_OPERATORS)[number];

// @public
export type Clause = CompoundClause | NotClause | TerminalClause;

// @public (undocumented)
export const CLAUSE_OPERATOR_NOT = 'not';

// @public (undocumented)
export const CLAUSE_TYPE_COMPOUND = 'compound';

// @public (undocumented)
export const CLAUSE_TYPE_NOT = 'not';

// @public (undocumented)
export const CLAUSE_TYPE_TERMINAL = 'terminal';

// @public (undocumented)
export const COLLAPSED_CUSTOM_FIELD_PATTERN: RegExp;

// @public (undocumented)
export const COLLAPSED_CUSTOM_FIELD_PATTERN_NO_QUOTES: RegExp;

// @public (undocumented)
export const COMPARISON_OPERATORS: readonly ['<', '>', '<=', '>='];

// @public (undocumented)
export type ComparisonOperator = BaseOperator<ComparisonOperatorValue>;

// @public (undocumented)
export type ComparisonOperatorValue = (typeof COMPARISON_OPERATORS)[number];

// @public (undocumented)
export const COMPONENT_FIELD = 'component';

// @public (undocumented)
export const COMPOUND_OPERATOR_AND = 'and';

// @public (undocumented)
export const COMPOUND_OPERATOR_OR = 'or';

// @public
export interface CompoundClause
	extends AstNode<ParentOfClause & AstNode>,
		Removable,
		Replaceable<Clause>,
		ParentOfClause {
	appendClause: (clause: Clause) => void;
	clauses: Clause[];
	// (undocumented)
	clauseType: typeof CLAUSE_TYPE_COMPOUND;
	operator: CompoundOperator;
	// (undocumented)
	type: typeof NODE_TYPE_CLAUSE;
}

// @public
export interface CompoundOperator extends AstNode {
	positions: Position[];
	value: CompoundOperatorValue;
}

// @public (undocumented)
export type CompoundOperatorValue = typeof COMPOUND_OPERATOR_AND | typeof COMPOUND_OPERATOR_OR;

// @public (undocumented)
export const computeJqlInsights: (jast: Jast) => JqlInsightsAttributes;

// @public (undocumented)
export const CREATED_FIELD = 'created';

// @public (undocumented)
export const CREATOR_PROPERTY = 'creator.property';

// @public (undocumented)
export const creators: {
	query: (where: Clause | void, orderBy?: OrderBy | undefined) => Query;
	compoundClause: (operator: CompoundOperator, clauses: Clause[]) => CompoundClause;
	compoundOperator: (value: CompoundOperatorValue) => CompoundOperator;
	terminalClause: (
		field: Field,
		operator?: Operator | undefined,
		operand?: Operand | undefined,
		predicates?: Predicate[],
	) => TerminalClause;
	notClause: (clause: Clause) => NotClause;
	notClauseOperator: () => NotClauseOperator;
	predicate: (operator: PredicateOperator, operand?: Operand | undefined) => Predicate;
	predicateOperator: (
		value: 'after' | 'before' | 'by' | 'during' | 'from' | 'on' | 'to',
	) => PredicateOperator;
	field: (value: string, properties?: Property[] | undefined) => Field;
	property: (key: Argument | void, path?: Argument[]) => Property;
	operator: (
		value:
			| '!='
			| '!~'
			| '<'
			| '<='
			| '='
			| '>'
			| '>='
			| 'changed'
			| 'in'
			| 'is not'
			| 'is'
			| 'not in'
			| 'was in'
			| 'was not in'
			| 'was not'
			| 'was'
			| '~',
	) => Operator;
	valueOperand: (value: string) => ValueOperand;
	keywordOperand: () => KeywordOperand;
	functionOperand: (functionString: FunctionString, args?: Argument[]) => FunctionOperand;
	functionString: (value: string) => FunctionString;
	argument: (value: string) => Argument;
	listOperand: (values: Operand[]) => ListOperand;
	orderBy: (fields: OrderByField[]) => OrderBy;
	orderByOperator: () => OrderByOperator;
	orderByField: (field: Field, direction?: OrderByDirection | undefined) => OrderByField;
	orderByDirection: (value: OrderByDirectionValue) => OrderByDirection;
	byText: {
		argument: (text: string) => Argument;
		valueOperand: (text: string) => ValueOperand;
	};
};

// @public (undocumented)
export const DESCRIPTION_FIELD = 'description';

// @public (undocumented)
export const DEVELOPMENT_FIELD = 'development';

// @public (undocumented)
export const DUE_DATE_FIELD = 'duedate';

// @public (undocumented)
export const ENVIRONMENT_FIELD = 'environment';

// @public (undocumented)
export const EPIC_LINK_FIELD = 'epic link';

// @public (undocumented)
export const EQUALS_OPERATORS: readonly ['=', '!='];

// @public (undocumented)
export type EqualsOperator = BaseOperator<EqualsOperatorValue>;

// @public (undocumented)
export type EqualsOperatorValue = (typeof EQUALS_OPERATORS)[number];

// @public
export interface Field extends AstNode {
	properties: Property[] | void;
	text: string;
	value: string;
}

// @public (undocumented)
export const FILTER_FIELD = 'filter';

// @public (undocumented)
export const FIX_VERSION_FIELD = 'fixversion';

// @public
export interface FunctionOperand extends AstNode {
	arguments: Argument[];
	function: FunctionString;
	// (undocumented)
	operandType: typeof OPERAND_TYPE_FUNCTION;
	// (undocumented)
	type: typeof NODE_TYPE_OPERAND;
}

// @public
export interface FunctionString extends AstNode {
	text: string;
	value: string;
}

// @public (undocumented)
export const IN_OPERATORS: readonly ['in', 'not in'];

// @public (undocumented)
export type InOperator = BaseOperator<InOperatorValue>;

// @public (undocumented)
export type InOperatorValue = (typeof IN_OPERATORS)[number];

// @public (undocumented)
export const IS_OPERATORS: readonly ['is', 'is not'];

// @public (undocumented)
export const isChangedOperator: (operator: string) => operator is 'changed';

// @public (undocumented)
export const isComparisonOperator: (operator: string) => operator is '<' | '<=' | '>' | '>=';

// @public (undocumented)
export const isEqualsOperator: (operator: string) => operator is '!=' | '=';

// @public (undocumented)
export const isInOperator: (operator: string) => operator is 'in' | 'not in';

// @public (undocumented)
export const isIsOperator: (operator: string) => operator is 'is not' | 'is';

// @public (undocumented)
export const isLikeOperator: (operator: string) => operator is '!~' | '~';

// @public (undocumented)
export const isListOperator: (
	operator: string,
) => operator is 'in' | 'not in' | 'was in' | 'was not in';

// @public (undocumented)
export const isOperandNode: (maybeOperandNode: AstNode) => maybeOperandNode is Operand;

// @public (undocumented)
export type IsOperator = BaseOperator<IsOperatorValue>;

// @public (undocumented)
export const isOperator: (
	operator: string,
) => operator is
	| '!='
	| '!~'
	| '<'
	| '<='
	| '='
	| '>'
	| '>='
	| 'changed'
	| 'in'
	| 'is not'
	| 'is'
	| 'not in'
	| 'was in'
	| 'was not in'
	| 'was not'
	| 'was'
	| '~';

// @public (undocumented)
export type IsOperatorValue = (typeof IS_OPERATORS)[number];

// @public (undocumented)
export const isPredicateOperator: (
	operator: string,
) => operator is 'after' | 'before' | 'by' | 'during' | 'from' | 'on' | 'to';

// @public (undocumented)
export const ISSUE_KEY_FIELD = 'issuekey';

// @public (undocumented)
export const ISSUE_PROPERTY = 'issue.property';

// @public (undocumented)
export const ISSUE_TYPE_FIELD = 'issuetype';

// @public (undocumented)
export const isWasInOperator: (operator: string) => operator is 'was in' | 'was not in';

// @public (undocumented)
export const isWasOperator: (operator: string) => operator is 'was not' | 'was';

// @public
export interface Jast {
	errors: JQLParseError[];
	query: Query | void;
	represents: string;
}

// @public (undocumented)
export class JastBuilder {
	// (undocumented)
	build(value: string): Jast;
	// (undocumented)
	setErrorHandler(errorHandler: ANTLRErrorStrategy): JastBuilder;
	// (undocumented)
	setErrorListeners(errorListeners: ParserErrorListener[]): JastBuilder;
}

// @public
export interface JastListener {
	// (undocumented)
	enterArgument?: (argument: Argument) => void;
	// (undocumented)
	enterCompoundClause?: (compoundClause: CompoundClause) => void;
	// (undocumented)
	enterCompoundOperator?: (compoundOperator: CompoundOperator) => void;
	// (undocumented)
	enterEveryNode?: (query: AstNode) => void;
	// (undocumented)
	enterField?: (field: Field) => void;
	// (undocumented)
	enterFunction?: (functionString: FunctionString) => void;
	// (undocumented)
	enterFunctionOperand?: (functionOperand: FunctionOperand) => void;
	// (undocumented)
	enterKeywordOperand?: (keywordOperand: KeywordOperand) => void;
	// (undocumented)
	enterListOperand?: (listOperand: ListOperand) => void;
	// (undocumented)
	enterNotClause?: (notClause: NotClause) => void;
	// (undocumented)
	enterNotClauseOperator?: (notClauseOperator: NotClauseOperator) => void;
	// (undocumented)
	enterOperator?: (operator: Operator) => void;
	// (undocumented)
	enterOrderBy?: (orderBy: OrderBy) => void;
	// (undocumented)
	enterOrderByDirection?: (orderByDirection: OrderByDirection) => void;
	// (undocumented)
	enterOrderByField?: (orderByField: OrderByField) => void;
	// (undocumented)
	enterOrderByOperator?: (orderByOperator: OrderByOperator) => void;
	// (undocumented)
	enterPredicate?: (predicate: Predicate) => void;
	// (undocumented)
	enterPredicateOperator?: (predicateOperator: PredicateOperator) => void;
	// (undocumented)
	enterProperty?: (field: Property) => void;
	// (undocumented)
	enterQuery?: (query: Query) => void;
	// (undocumented)
	enterTerminalClause?: (terminalClause: TerminalClause) => void;
	// (undocumented)
	enterValueOperand?: (valueOperand: ValueOperand) => void;
	// (undocumented)
	exitArgument?: (argument: Argument) => void;
	// (undocumented)
	exitCompoundClause?: (compoundClause: CompoundClause) => void;
	// (undocumented)
	exitCompoundOperator?: (compoundOperator: CompoundOperator) => void;
	// (undocumented)
	exitEveryNode?: (query: AstNode) => void;
	// (undocumented)
	exitField?: (field: Field) => void;
	// (undocumented)
	exitFunction?: (functionString: FunctionString) => void;
	// (undocumented)
	exitFunctionOperand?: (functionOperand: FunctionOperand) => void;
	// (undocumented)
	exitKeywordOperand?: (keywordOperand: KeywordOperand) => void;
	// (undocumented)
	exitListOperand?: (listOperand: ListOperand) => void;
	// (undocumented)
	exitNotClause?: (notClause: NotClause) => void;
	// (undocumented)
	exitNotClauseOperator?: (notClauseOperator: NotClauseOperator) => void;
	// (undocumented)
	exitOperator?: (operator: Operator) => void;
	// (undocumented)
	exitOrderBy?: (orderBy: OrderBy) => void;
	// (undocumented)
	exitOrderByDirection?: (orderByDirection: OrderByDirection) => void;
	// (undocumented)
	exitOrderByField?: (orderByField: OrderByField) => void;
	// (undocumented)
	exitOrderByOperator?: (orderByOperator: OrderByOperator) => void;
	// (undocumented)
	exitPredicate?: (predicate: Predicate) => void;
	// (undocumented)
	exitPredicateOperator?: (predicateOperator: PredicateOperator) => void;
	// (undocumented)
	exitProperty?: (field: Property) => void;
	// (undocumented)
	exitQuery?: (query: Query) => void;
	// (undocumented)
	exitTerminalClause?: (terminalClause: TerminalClause) => void;
	// (undocumented)
	exitValueOperand?: (valueOperand: ValueOperand) => void;
}

// @public
export interface JastVisitor<Result> {
	visit(node: AstNode): Result;
	// (undocumented)
	visitArgument?: (argument: Argument) => Result;
	visitChildren(node: AstNode): Result;
	// (undocumented)
	visitCompoundClause?: (compoundClause: CompoundClause) => Result;
	// (undocumented)
	visitCompoundOperator?: (compoundOperator: CompoundOperator) => Result;
	// (undocumented)
	visitField?: (field: Field) => Result;
	// (undocumented)
	visitFunction?: (functionString: FunctionString) => Result;
	// (undocumented)
	visitFunctionOperand?: (functionOperand: FunctionOperand) => Result;
	// (undocumented)
	visitKeywordOperand?: (keywordOperand: KeywordOperand) => Result;
	// (undocumented)
	visitListOperand?: (listOperand: ListOperand) => Result;
	// (undocumented)
	visitNotClause?: (notClause: NotClause) => Result;
	// (undocumented)
	visitNotClauseOperator?: (notClauseOperator: NotClauseOperator) => Result;
	// (undocumented)
	visitOperator?: (operator: Operator) => Result;
	// (undocumented)
	visitOrderBy?: (orderBy: OrderBy) => Result;
	// (undocumented)
	visitOrderByDirection?: (orderByDirection: OrderByDirection) => Result;
	// (undocumented)
	visitOrderByField?: (orderByField: OrderByField) => Result;
	// (undocumented)
	visitOrderByOperator?: (orderByOperator: OrderByOperator) => Result;
	// (undocumented)
	visitPredicate?: (predicate: Predicate) => Result;
	// (undocumented)
	visitPredicateOperator?: (predicateOperator: PredicateOperator) => Result;
	// (undocumented)
	visitProperty?: (property: Property) => Result;
	// (undocumented)
	visitQuery?: (query: Query) => Result;
	// (undocumented)
	visitTerminalClause?: (terminalClause: TerminalClause) => Result;
	// (undocumented)
	visitValueOperand?: (valueOperand: ValueOperand) => Result;
}

// @public (undocumented)
export class JqlAnonymizerVisitor extends AbstractJastVisitor<string> {
	// (undocumented)
	protected defaultResult(): string;
	// (undocumented)
	visitCompoundClause: (compoundClause: CompoundClause) => string;
	// (undocumented)
	visitField: (field: Field) => string;
	// (undocumented)
	visitFunctionOperand: (functionOperand: FunctionOperand) => string;
	// (undocumented)
	visitKeywordOperand: (keywordOperand: KeywordOperand) => string;
	// (undocumented)
	visitListOperand: (listOperand: ListOperand) => string;
	// (undocumented)
	visitNotClause: (notClause: NotClause) => string;
	// (undocumented)
	visitOrderBy: (orderBy: OrderBy) => string;
	// (undocumented)
	visitPredicate: (predicate: Predicate) => string;
	// (undocumented)
	visitQuery: (query: Query) => string;
	// (undocumented)
	visitTerminalClause: (terminalClause: TerminalClause) => string;
	// (undocumented)
	visitValueOperand: () => string;
}

// @public
export type JqlInsightsAttributes = {
	jqlFieldValueCount: {
		issueType: number;
		project: number;
		assignee: number;
		reporter: number;
		priority: number;
		status: number;
		resolution: number;
		team: number;
	};
	jqlFieldIsUsed: {
		summary: boolean;
		due: boolean;
		resolutionDate: boolean;
		created: boolean;
		lastviewed: boolean;
		updated: boolean;
		team: boolean;
	};
	jqlUsedFields: string[];
	jqlUsedFieldsCount: number;
	jqlUsedFieldsOrderBy: string[];
	jqlLineCount: number;
	jqlErrorCount: number;
	jqlClauseCount: {
		orderBy: number;
		leaf: number;
		and: number;
		not: number;
		or: number;
	};
	jqlMaxCompoundClauseDepth: number;
};

// @public
export class JQLParseError extends Error {
	constructor(message: string, cause?: Error);
	cause?: Error;
	description: string;
}

// @public
export class JQLSyntaxError extends JQLParseError {
	constructor(
		message: string,
		start: number,
		stop: number,
		line: number,
		charPositionInLine: number,
	);
	charPositionInLine: number;
	line: number;
	start: number;
	stop: number;
}

// @public
export interface KeywordOperand extends AstNode {
	// (undocumented)
	operandType: typeof OPERAND_TYPE_KEYWORD;
	// (undocumented)
	type: typeof NODE_TYPE_OPERAND;
	value: KeywordOperandValue;
}

// @public (undocumented)
export type KeywordOperandValue = typeof OPERAND_EMPTY;

// @public (undocumented)
export const LABELS_FIELD = 'labels';

// @public (undocumented)
export const LAST_VIEWED_FIELD = 'lastviewed';

// @public (undocumented)
export const LIKE_OPERATORS: readonly ['~', '!~'];

// @public (undocumented)
export type LikeOperator = BaseOperator<LikeOperatorValue>;

// @public (undocumented)
export type LikeOperatorValue = (typeof LIKE_OPERATORS)[number];

// @public (undocumented)
export const LIST_OPERATORS: readonly ['in', 'not in', 'was in', 'was not in'];

// @public
export interface ListOperand extends AstNode {
	appendOperand: (this: ListOperand, operand: Operand) => void;
	// (undocumented)
	operandType: typeof OPERAND_TYPE_LIST;
	// (undocumented)
	type: typeof NODE_TYPE_OPERAND;
	values: Operand[];
}

// @public (undocumented)
export type ListOperatorValue = (typeof LIST_OPERATORS)[number];

// @public (undocumented)
export const NODE_TYPE_CLAUSE = 'clause';

// @public (undocumented)
export const NODE_TYPE_OPERAND = 'operand';

// @public (undocumented)
export const NODE_TYPE_ORDER_BY = 'order_by';

// @public (undocumented)
export const NODE_TYPE_QUERY = 'query';

// @public
export const normaliseJqlString: (maybeQuotedString: string) => string;

// @public
export interface NotClause
	extends AstNode<ParentOfClause & AstNode>,
		Removable,
		Replaceable<Clause>,
		ParentOfClause {
	// (undocumented)
	clause: Clause;
	// (undocumented)
	clauseType: typeof CLAUSE_TYPE_NOT;
	// (undocumented)
	operator: NotClauseOperator;
	// (undocumented)
	type: typeof NODE_TYPE_CLAUSE;
}

// @public
export interface NotClauseOperator extends AstNode {
	// (undocumented)
	value: typeof CLAUSE_OPERATOR_NOT;
}

// @public
export type Operand = FunctionOperand | KeywordOperand | ListOperand | ValueOperand;

// @public (undocumented)
export const OPERAND_EMPTY = 'empty';

// @public (undocumented)
export const OPERAND_TYPE_FUNCTION = 'function';

// @public (undocumented)
export const OPERAND_TYPE_KEYWORD = 'keyword';

// @public (undocumented)
export const OPERAND_TYPE_LIST = 'list';

// @public (undocumented)
export const OPERAND_TYPE_VALUE = 'value';

// @public (undocumented)
export type OperandType =
	| typeof OPERAND_TYPE_FUNCTION
	| typeof OPERAND_TYPE_KEYWORD
	| typeof OPERAND_TYPE_LIST
	| typeof OPERAND_TYPE_VALUE;

// @public (undocumented)
export type Operator =
	| ChangedOperator
	| ComparisonOperator
	| EqualsOperator
	| InOperator
	| IsOperator
	| LikeOperator
	| WasInOperator
	| WasOperator;

// @public (undocumented)
export const OPERATOR_CHANGED = 'changed';

// @public (undocumented)
export const OPERATOR_EQUALS = '=';

// @public (undocumented)
export const OPERATOR_GT = '>';

// @public (undocumented)
export const OPERATOR_GT_EQUALS = '>=';

// @public (undocumented)
export const OPERATOR_IN = 'in';

// @public (undocumented)
export const OPERATOR_IS = 'is';

// @public (undocumented)
export const OPERATOR_IS_NOT = 'is not';

// @public (undocumented)
export const OPERATOR_LIKE = '~';

// @public (undocumented)
export const OPERATOR_LT = '<';

// @public (undocumented)
export const OPERATOR_LT_EQUALS = '<=';

// @public (undocumented)
export const OPERATOR_NOT_EQUALS = '!=';

// @public (undocumented)
export const OPERATOR_NOT_IN = 'not in';

// @public (undocumented)
export const OPERATOR_NOT_LIKE = '!~';

// @public (undocumented)
export const OPERATOR_WAS = 'was';

// @public (undocumented)
export const OPERATOR_WAS_IN = 'was in';

// @public (undocumented)
export const OPERATOR_WAS_NOT = 'was not';

// @public (undocumented)
export const OPERATOR_WAS_NOT_IN = 'was not in';

// @public (undocumented)
export const OPERATORS: readonly [
	'=',
	'!=',
	'~',
	'!~',
	'<',
	'>',
	'<=',
	'>=',
	'in',
	'not in',
	'is',
	'is not',
	'was',
	'was not',
	'was in',
	'was not in',
	'changed',
];

// @public (undocumented)
export type OperatorValue = (typeof OPERATORS)[number];

// @public (undocumented)
export const ORDER_BY_DIRECTION_ASC = 'ASC';

// @public (undocumented)
export const ORDER_BY_DIRECTION_DESC = 'DESC';

// @public (undocumented)
export const ORDER_BY_OPERATOR_ORDER_BY = 'ORDER BY';

// @public
export interface OrderBy extends AstNode {
	fields: OrderByField[];
	operator: OrderByOperator;
	prependOrderField: (orderField: OrderByField) => void;
	setOrderDirection: (orderDirection: OrderByDirection) => void;
	// (undocumented)
	type: typeof NODE_TYPE_ORDER_BY;
}

// @public
export interface OrderByDirection extends AstNode {
	value: OrderByDirectionValue;
}

// @public (undocumented)
export type OrderByDirectionValue = typeof ORDER_BY_DIRECTION_ASC | typeof ORDER_BY_DIRECTION_DESC;

// @public
export interface OrderByField extends AstNode {
	direction: OrderByDirection | void;
	field: Field;
	setOrderDirection: (orderDirection: OrderByDirection) => void;
}

// @public
export interface OrderByOperator extends AstNode {
	value: typeof ORDER_BY_OPERATOR_ORDER_BY;
}

// @public (undocumented)
export const PARENT_FIELD = 'parent';

// @public (undocumented)
export interface ParentOfClause {
	removeClause: (clause: Clause) => void;
	replaceClause: (clause: Clause, nextClause: Clause) => void;
}

// @public
export type Position = [number, number];

// @public
export interface Predicate extends AstNode {
	operand: Operand | void;
	operator: PredicateOperator;
}

// @public (undocumented)
export const PREDICATE_OPERATOR_AFTER = 'after';

// @public (undocumented)
export const PREDICATE_OPERATOR_BEFORE = 'before';

// @public (undocumented)
export const PREDICATE_OPERATOR_BY = 'by';

// @public (undocumented)
export const PREDICATE_OPERATOR_DURING = 'during';

// @public (undocumented)
export const PREDICATE_OPERATOR_FROM = 'from';

// @public (undocumented)
export const PREDICATE_OPERATOR_ON = 'on';

// @public (undocumented)
export const PREDICATE_OPERATOR_TO = 'to';

// @public (undocumented)
export const PREDICATE_OPERATORS: readonly ['after', 'before', 'by', 'during', 'from', 'on', 'to'];

// @public
export interface PredicateOperator extends AstNode {
	text: string;
	value: PredicateOperatorValue;
}

// @public (undocumented)
export type PredicateOperatorValue = (typeof PREDICATE_OPERATORS)[number];

// @public
const print_2: (jast: Jast, options?: PrintOptions) => string;
export { print_2 as print };

// @public (undocumented)
type PrintOptions = {
	printWidth?: null | number;
};

// @public (undocumented)
export const PRIORITY_FIELD = 'priority';

// @public (undocumented)
export const PRIVACY_SAFE_FIELDS: string[];

// @public (undocumented)
export const PROJECT_FIELD = 'project';

// @public (undocumented)
export const PROJECT_PROPERTY = 'project.property';

// @public
export interface Property extends AstNode {
	key: Argument | void;
	path: Argument[] | void;
}

// @public
export interface Query extends AstNode, ParentOfClause {
	appendClause: (clause: Clause, compoundOperatorValue: CompoundOperatorValue) => void;
	orderBy: OrderBy | void;
	prependOrderField: (orderField: OrderByField) => void;
	setOrderDirection: (orderDirection: OrderByDirection) => void;
	// (undocumented)
	type: typeof NODE_TYPE_QUERY;
	where: Clause | void;
}

// @public
export interface Removable {
	remove: () => void;
}

// @public
export interface Replaceable<T extends AstNode> {
	replace: (node: T) => void;
}

// @public (undocumented)
export const REPORTER_FIELD = 'reporter';

// @public (undocumented)
export const REPORTER_PROPERTY = 'reporter.property';

// @public (undocumented)
export const RESOLUTION_DATE_FIELD = 'resolutiondate';

// @public (undocumented)
export const RESOLUTION_FIELD = 'resolution';

// @public (undocumented)
export const RESOLVED_FIELD = 'resolved';

// @public
export const sanitiseJqlString: (jqlString: string) => string;

// @public (undocumented)
export const SPRINT_FIELD = 'sprint';

// @public (undocumented)
export const STATUS_CATEGORY_FIELD = 'statuscategory';

// @public (undocumented)
export const STATUS_FIELD = 'status';

// @public
export type StringValue = {
	text: string;
	value: string;
	position: Position | null;
};

// @public (undocumented)
export const SUMMARY_FIELD = 'summary';

// @public (undocumented)
export const TEAM_CUSTOM_FIELD_TYPE = '[team]';

// @public
export interface TerminalClause
	extends AstNode<ParentOfClause & AstNode>,
		Removable,
		Replaceable<Clause> {
	appendOperand: (this: TerminalClause, operand: Operand) => void;
	// (undocumented)
	clauseType: typeof CLAUSE_TYPE_TERMINAL;
	field: Field;
	operand: Operand | void;
	operator: Operator | void;
	predicates: Predicate[];
	setOperand: (this: TerminalClause, operand: Operand) => void;
	setOperator: (this: TerminalClause, operator: Operator) => void;
	// (undocumented)
	type: typeof NODE_TYPE_CLAUSE;
}

// @public (undocumented)
export type TerminalClauseRhs = Pick<TerminalClause, 'operand' | 'operator' | 'predicates'>;

// @public (undocumented)
export const TEXT_FIELD = 'text';

// @public (undocumented)
export const TYPE_FIELD = 'type';

// @public (undocumented)
export const UPDATED_FIELD = 'updated';

// @public
export interface ValueOperand extends AstNode {
	// (undocumented)
	operandType: typeof OPERAND_TYPE_VALUE;
	text: string;
	// (undocumented)
	type: typeof NODE_TYPE_OPERAND;
	value: string;
}

// @public (undocumented)
export const VOTER_PROPERTY = 'voter.property';

// @public
export const walkAST: (listener: JastListener, jast: Jast) => void;

// @public (undocumented)
export const WAS_IN_OPERATORS: readonly ['was in', 'was not in'];

// @public (undocumented)
export const WAS_OPERATORS: readonly ['was', 'was not'];

// @public (undocumented)
export type WasInOperator = BaseOperator<WasInOperatorValue>;

// @public (undocumented)
export type WasInOperatorValue = (typeof WAS_IN_OPERATORS)[number];

// @public (undocumented)
export type WasOperator = BaseOperator<WasOperatorValue>;

// @public (undocumented)
export type WasOperatorValue = (typeof WAS_OPERATORS)[number];

// @public (undocumented)
export const WATCHER_PROPERTY = 'watcher.property';

// (No @packageDocumentation comment for this package)
```

<!--SECTION END: Main Entry Types-->

### Peer Dependencies

<!--SECTION START: Peer Dependencies-->

```json
{}
```

<!--SECTION END: Peer Dependencies-->
