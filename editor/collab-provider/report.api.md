<!-- API Report Version: 2.3 -->

## API Report File for "@atlaskit/collab-provider"

> Do not edit this file. This report is auto-generated using [API Extractor](https://api-extractor.com/).
> [Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

### Table of contents

- [Main Entry Types](#main-entry-types)
- [Peer Dependencies](#peer-dependencies)

### Main Entry Types

<!--SECTION START: Main Entry Types-->

```ts
import type { AnalyticsWebClient } from '@atlaskit/analytics-listeners';
import type { EditorState } from 'prosemirror-state';
import { JSONDocNode } from '@atlaskit/editor-json-transformer';
import type { Manager } from 'socket.io-client';
import type { Step } from 'prosemirror-transform';
import type { Transaction } from 'prosemirror-state';

// @public (undocumented)
type AuthCallback = (cb: (data: InitAndAuthData) => void) => void;

// @public (undocumented)
type BaseEvents = Pick<
  CollabEditProvider<CollabEvents>,
  'send' | 'sendMessage' | 'setup'
>;

// @public (undocumented)
type CollabCommitStatusEventPayload = {
  status: 'attempt' | 'failure' | 'success';
  version: number;
};

// @public (undocumented)
export type CollabConnectedPayload = CollabEventConnectionData;

// @public (undocumented)
type CollabConnectingPayload = CollabEventConnectingData;

// @public (undocumented)
export interface CollabDataPayload extends CollabEventRemoteData {
  // (undocumented)
  json: StepJson[];
  // (undocumented)
  userIds: (number | string)[];
  // (undocumented)
  version: number;
}

// @public (undocumented)
export interface CollabDisconnectedPayload {
  // (undocumented)
  reason: DisconnectReason;
  // (undocumented)
  sid: string;
}

// @public (undocumented)
export interface CollabEditProvider<
  Events extends CollabEvents = CollabEvents,
> {
  // (undocumented)
  getFinalAcknowledgedState(): Promise<ResolvedEditorState>;
  // (undocumented)
  initialize(getState: () => any, createStep: (json: object) => Step): this;
  // (undocumented)
  off(evt: keyof Events, handler: (...args: any) => void): this;
  // (undocumented)
  on(evt: keyof Events, handler: (...args: any) => void): this;
  // (undocumented)
  send(tr: Transaction, oldState: EditorState, newState: EditorState): void;
  // (undocumented)
  sendMessage<K extends keyof Events>(
    data: {
      type: K;
    } & Events[K],
  ): void;
  // (undocumented)
  setup(props: {
    getState?: () => EditorState;
    onSyncUpError?: SyncUpErrorFunction;
  }): this;
  // (undocumented)
  unsubscribeAll(evt: keyof Events): this;
}

// @public (undocumented)
export interface CollabEventConnectingData {
  // (undocumented)
  initial: boolean;
}

// @public (undocumented)
export interface CollabEventConnectionData {
  // (undocumented)
  initial: boolean;
  // (undocumented)
  sid: string;
}

// @public (undocumented)
export interface CollabEventDisconnectedData {
  // (undocumented)
  reason:
    | 'CLIENT_DISCONNECT'
    | 'SERVER_DISCONNECT'
    | 'SOCKET_CLOSED'
    | 'SOCKET_ERROR'
    | 'SOCKET_TIMEOUT'
    | 'UNKNOWN_DISCONNECT';
  // (undocumented)
  sid: string;
}

// @public (undocumented)
export interface CollabEventInitData {
  // (undocumented)
  doc?: any;
  // (undocumented)
  json?: any;
  // (undocumented)
  reserveCursor?: boolean;
  // (undocumented)
  sid?: string;
  // (undocumented)
  version?: number;
}

// @public (undocumented)
export interface CollabEventLocalStepData {
  // (undocumented)
  steps: Array<Step>;
}

// @public (undocumented)
export interface CollabEventPresenceData {
  // (undocumented)
  joined?: ProviderParticipant[];
  // (undocumented)
  left?: {
    sessionId: string;
  }[];
}

// @public (undocumented)
export interface CollabEventRemoteData {
  // (undocumented)
  json?: any;
  // (undocumented)
  newState?: EditorState;
  // (undocumented)
  userIds?: (number | string)[];
}

// @public (undocumented)
export interface CollabEvents {
  // (undocumented)
  'commit-status': CollabCommitStatusEventPayload;
  // (undocumented)
  'local-steps': CollabLocalStepsPayload;
  // (undocumented)
  'metadata:changed': CollabMetadataPayload;
  // (undocumented)
  connected: CollabConnectedPayload;
  // (undocumented)
  connecting: CollabConnectingPayload;
  // (undocumented)
  data: CollabDataPayload;
  // (undocumented)
  disconnected: CollabDisconnectedPayload;
  // (undocumented)
  entity: any;
  // (undocumented)
  error: ProviderError;
  // (undocumented)
  init: CollabInitPayload;
  // (undocumented)
  presence: CollabPresencePayload;
  // (undocumented)
  telepointer: CollabTelepointerPayload;
}

// @public (undocumented)
export interface CollabEventTelepointerData {
  // (undocumented)
  selection: CollabSendableSelection;
  // (undocumented)
  sessionId: string;
  // (undocumented)
  type: 'telepointer';
}

// @public (undocumented)
export interface CollabInitPayload extends CollabEventInitData {
  // (undocumented)
  doc: any;
  // (undocumented)
  metadata?: Metadata_2;
  // (undocumented)
  reserveCursor?: boolean;
  // (undocumented)
  version: number;
}

// @public (undocumented)
export type CollabLocalStepsPayload = {
  steps: readonly Step[];
};

// @public (undocumented)
export type CollabMetadataPayload = Metadata_2;

// @public (undocumented)
export interface CollabParticipant {
  // (undocumented)
  avatar: string;
  // (undocumented)
  cursorPos?: number;
  // (undocumented)
  lastActive: number;
  // (undocumented)
  name: string;
  // (undocumented)
  sessionId: string;
}

// @public (undocumented)
export type CollabPresencePayload = CollabEventPresenceData;

// @public (undocumented)
export interface CollabSendableSelection {
  // (undocumented)
  anchor?: number | string;
  // (undocumented)
  head?: number | string;
  // (undocumented)
  type: 'nodeSelection' | 'textSelection';
}

// @public (undocumented)
export type CollabTelepointerPayload = CollabEventTelepointerData;

// @public (undocumented)
interface Config {
  analyticsClient?: AnalyticsWebClient;
  // (undocumented)
  cacheToken?: boolean;
  // (undocumented)
  createSocket: (
    path: string,
    auth?: AuthCallback | InitAndAuthData,
    productInfo?: ProductInformation,
  ) => Socket;
  // (undocumented)
  documentAri: string;
  enableErrorOnFailedDocumentApply?: boolean;
  failedStepLimitBeforeCatchupOnPublish?: number;
  // (undocumented)
  featureFlags?: {
    [key: string]: boolean;
  };
  // (undocumented)
  getAnalyticsWebClient?: Promise<AnalyticsWebClient>;
  // (undocumented)
  getUser?: GetUserType;
  // (undocumented)
  initialDraft?: InitialDraft;
  // (undocumented)
  lifecycle?: Lifecycle;
  // (undocumented)
  need404?: boolean;
  permissionTokenRefresh?: () => Promise<null | string>;
  // (undocumented)
  productInfo?: ProductInformation;
  // (undocumented)
  storage?: Storage_2;
  throwOnNotConnected?: boolean;
  // (undocumented)
  url: string;
}

// @public (undocumented)
enum DisconnectReason {
  // (undocumented)
  CLIENT_DISCONNECT = 'CLIENT_DISCONNECT',
  // (undocumented)
  SERVER_DISCONNECT = 'SERVER_DISCONNECT',
  // (undocumented)
  SOCKET_CLOSED = 'SOCKET_CLOSED',
  // (undocumented)
  SOCKET_ERROR = 'SOCKET_ERROR',
  // (undocumented)
  SOCKET_TIMEOUT = 'SOCKET_TIMEOUT',
  // (undocumented)
  UNKNOWN_DISCONNECT = 'UNKNOWN_DISCONNECT',
}

// @public
type DocumentNotFound = {
  code: PROVIDER_ERROR_CODE.DOCUMENT_NOT_FOUND;
  message: string;
  recoverable: boolean;
  status?: number;
};

// @public
type DocumentNotRestore = {
  code: PROVIDER_ERROR_CODE.DOCUMENT_RESTORE_ERROR;
  message: string;
  recoverable: boolean;
  status?: number;
};

// @public (undocumented)
class Emitter<T = any> {
  protected emit<K extends keyof T>(evt: K, data: T[K]): this;
  off<K extends keyof T>(evt: K, handler: (args: T[K]) => void): this;
  on<K extends keyof T>(evt: K, handler: (args: T[K]) => void): this;
  unsubscribeAll<K extends keyof T>(evt?: K): this;
}

// @public (undocumented)
type EventHandler = () => void;

// @public
type FailToSave = {
  code: PROVIDER_ERROR_CODE.FAIL_TO_SAVE;
  message: string;
  recoverable: boolean;
  status?: number;
};

// @public (undocumented)
type GetUserType =
  | ((
      userId: string,
    ) => Promise<
      Pick<ProviderParticipant, 'avatar' | 'email' | 'name' | 'userId'>
    >)
  | undefined;

// @public (undocumented)
interface InitAndAuthData {
  // (undocumented)
  initialized: boolean;
  // (undocumented)
  need404?: boolean;
  // (undocumented)
  token?: string;
}

// @public (undocumented)
interface InitialDraft {
  // (undocumented)
  document: JSONDocNode;
  // (undocumented)
  metadata?: Metadata_2;
  // (undocumented)
  timestamp?: number;
  // (undocumented)
  version: number;
}

// @public
type InitialisationError = {
  code: PROVIDER_ERROR_CODE.INITIALISATION_ERROR;
  message: string;
  recoverable: boolean;
  status?: number;
};

// @public
type InsufficientEditingPermission = {
  code: PROVIDER_ERROR_CODE.NO_PERMISSION_ERROR;
  message: string;
  recoverable: boolean;
  reason?: string;
  status?: number;
};

// @public
type InternalServiceError = {
  code: PROVIDER_ERROR_CODE.INTERNAL_SERVICE_ERROR;
  message: string;
  recoverable: boolean;
  reason: string;
  status?: number;
};

// @public
type InvalidProviderConfiguration = {
  code: PROVIDER_ERROR_CODE.INVALID_PROVIDER_CONFIGURATION;
  message: string;
  recoverable: boolean;
  reason: string;
  status?: number;
};

// @public
type InvalidUserToken = {
  code: PROVIDER_ERROR_CODE.INVALID_USER_TOKEN;
  message: string;
  recoverable: boolean;
  status?: number;
};

// @public (undocumented)
interface Lifecycle {
  // (undocumented)
  on(event: LifecycleEvents, handler: EventHandler): void;
}

// @public (undocumented)
type LifecycleEvents = 'restore' | 'save';

// @public
type Locked = {
  code: PROVIDER_ERROR_CODE.LOCKED;
  message: string;
  recoverable: boolean;
  status?: number;
};

// @public (undocumented)
type MarkJson = {
  type: string;
  attrs: {
    [key: string]: any;
  };
};

// @public (undocumented)
interface Metadata_2 {
  // (undocumented)
  [key: string]: boolean | number | string;
}

// @public
type NetworkIssue = {
  code: PROVIDER_ERROR_CODE.NETWORK_ISSUE;
  message: string;
  recoverable: boolean;
  status?: number;
};

// @public (undocumented)
export type NewCollabSyncUpErrorAttributes = {
  lengthOfUnconfirmedSteps?: number;
  tries: number;
  maxRetries: number;
  clientId?: number | string;
  version: number;
};

// @public (undocumented)
type NodeJson = {
  type: string;
  attrs: {
    [key: string]: any;
  };
  content: NodeJson[];
  marks: MarkJson[];
  text?: string;
};

// @public (undocumented)
type ProductInformation = {
  product: string;
  subProduct?: string;
};

// @public (undocumented)
export class Provider extends Emitter<CollabEvents> implements BaseEvents {
  constructor(config: Config);
  destroy(): this;
  // @deprecated
  disconnect(): this;
  getCurrentState: () => Promise<ResolvedEditorState>;
  getFinalAcknowledgedState: () => Promise<ResolvedEditorState>;
  getMetadata: () => Metadata_2;
  // (undocumented)
  getParticipants: () => ProviderParticipant[];
  // (undocumented)
  getStatePromiseResolve: (value: PromiseLike<void> | void) => void;
  // (undocumented)
  getUnconfirmedSteps: () => readonly Step[] | undefined;
  // @deprecated
  initialize(getState: () => EditorState): this;
  send(
    _tr: Transaction | null,
    _oldState: EditorState | null,
    newState: EditorState,
  ): void;
  sendMessage(data: CollabTelepointerPayload): void;
  // @deprecated
  setEditorWidth(editorWidth: string, broadcast?: boolean): void;
  setMetadata(metadata: Metadata_2): void;
  // @deprecated
  setTitle(title: string, broadcast?: boolean): void;
  setup({
    getState,
    onSyncUpError,
  }: {
    getState?: () => EditorState;
    onSyncUpError?: SyncUpErrorFunction;
  }): this;
  // @deprecated
  unsubscribeAll(): this;
}

// @public (undocumented)
export enum PROVIDER_ERROR_CODE {
  // (undocumented)
  DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND',
  // (undocumented)
  DOCUMENT_RESTORE_ERROR = 'DOCUMENT_RESTORE_ERROR',
  // (undocumented)
  DOCUMENT_UPDATE_ERROR = 'DOCUMENT_UPDATE_ERROR',
  // (undocumented)
  FAIL_TO_SAVE = 'FAIL_TO_SAVE',
  // (undocumented)
  INITIALISATION_ERROR = 'INITIALISATION_ERROR',
  // (undocumented)
  INTERNAL_SERVICE_ERROR = 'INTERNAL_SERVICE_ERROR',
  // (undocumented)
  INVALID_PROVIDER_CONFIGURATION = 'INVALID_PROVIDER_CONFIGURATION',
  // (undocumented)
  INVALID_USER_TOKEN = 'INVALID_USER_TOKEN',
  // (undocumented)
  LOCKED = 'LOCKED',
  // (undocumented)
  NETWORK_ISSUE = 'NETWORK_ISSUE',
  // (undocumented)
  NO_PERMISSION_ERROR = 'NO_PERMISSION_ERROR',
}

// @public (undocumented)
type ProviderDocumentUpdateError = {
  code: PROVIDER_ERROR_CODE.DOCUMENT_UPDATE_ERROR;
  message: 'The provider failed to apply changes to the editor';
  recoverable: boolean;
  status?: number;
};

// @public
export type ProviderError =
  | DocumentNotFound
  | DocumentNotRestore
  | FailToSave
  | InitialisationError
  | InsufficientEditingPermission
  | InternalServiceError
  | InvalidProviderConfiguration
  | InvalidUserToken
  | Locked
  | NetworkIssue
  | ProviderDocumentUpdateError;

// @public (undocumented)
export type ProviderParticipant = CollabParticipant & {
  userId: string;
  clientId: number | string;
  email: string;
};

// @public (undocumented)
export type ResolvedEditorState<T = any> = {
  content: JSONDocNode | T;
  title: null | string;
  stepVersion: number;
};

// @public (undocumented)
interface SimpleEventEmitter {
  // (undocumented)
  on(event: string, fn: Function): SimpleEventEmitter;
}

// @public (undocumented)
type SliceJson = {
  content: NodeJson[];
  openStart: number;
  openEnd: number;
};

// @public (undocumented)
export interface Socket extends SimpleEventEmitter {
  // (undocumented)
  close(): Socket;
  // (undocumented)
  connect(): Socket;
  // (undocumented)
  emit(event: string, ...args: any[]): Socket;
  // (undocumented)
  id: string;
  // (undocumented)
  io?: Manager;
}

// @public (undocumented)
type StepJson = {
  stepType?: string;
  from?: number;
  to?: number;
  slice?: SliceJson;
  clientId: number | string;
  userId: string;
  createdAt?: number;
  structure?: boolean;
};

// @public (undocumented)
interface Storage_2 {
  // (undocumented)
  delete(key: string): Promise<void>;
  // (undocumented)
  get(key: string): Promise<string>;
  // (undocumented)
  set(key: string, value: string): Promise<void>;
}

// @public (undocumented)
export type SyncUpErrorFunction = (
  attributes: NewCollabSyncUpErrorAttributes,
) => void;

// (No @packageDocumentation comment for this package)
```

<!--SECTION END: Main Entry Types-->

### Peer Dependencies

<!--SECTION START: Peer Dependencies-->

```json
{}
```

<!--SECTION END: Peer Dependencies-->
