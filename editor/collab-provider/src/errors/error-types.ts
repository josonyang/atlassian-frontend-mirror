// Internal error codes (generated by collab provider)
export enum INTERNAL_ERROR_CODE {
  TOKEN_PERMISSION_ERROR = 'TOKEN_PERMISSION_ERROR',
  RECONNECTION_NETWORK_ISSUE = 'RECONNECTION_NETWORK_ISSUE',
  CONNECTION_ERROR = 'CONNECTION_ERROR',
  RECONNECTION_ERROR = 'RECONNECTION_ERROR',
  DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND',
  CATCHUP_FAILED = 'CATCHUP_FAILED',
  DOCUMENT_RESTORE_ERROR = 'DOCUMENT_RESTORE_ERROR',
  ADD_STEPS_ERROR = 'ADD_STEPS_ERROR',
}
// NCS error coded (generated by NCS)
export enum NCS_ERROR_CODE {
  HEAD_VERSION_UPDATE_FAILED = 'HEAD_VERSION_UPDATE_FAILED',
  VERSION_NUMBER_ALREADY_EXISTS = 'VERSION_NUMBER_ALREADY_EXISTS',
  INSUFFICIENT_EDITING_PERMISSION = 'INSUFFICIENT_EDITING_PERMISSION',
  FORBIDDEN_USER_TOKEN = 'FORBIDDEN_USER_TOKEN',
  DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND',
  INIT_DATA_LOAD_FAILED = 'INIT_DATA_LOAD_FAILED',
  ERROR_MAPPING_ERROR = 'ERROR_MAPPING_ERROR',
  NAMESPACE_INVALID = 'NAMESPACE_INVALID',
  NAMESPACE_NOT_FOUND = 'NAMESPACE_NOT_FOUND',
  TENANT_INSTANCE_MAINTENANCE = 'TENANT_INSTANCE_MAINTENANCE',
  LOCKED_DOCUMENT = 'LOCKED_DOCUMENT',
  EMPTY_BROADCAST = 'EMPTY_BROADCAST',
  DYNAMO_ERROR = 'DYNAMO_ERROR',
  INVALID_ACTIVATION_ID = 'INVALID_ACTIVATION_ID',
  INVALID_DOCUMENT_ARI = 'INVALID_DOCUMENT_ARI',
  INVALID_CLOUD_ID = 'INVALID_CLOUD_ID',
}

// TODO: Import emitted error codes from NCS

// NCS Errors
// - Step rejection errors
type HeadVersionUpdateFailedError = {
  message: string; // Version number does not match current head version.
  data: {
    code: NCS_ERROR_CODE.HEAD_VERSION_UPDATE_FAILED;
    meta: {
      currentVersion: any; // But likely a number
      incomingVersion: number;
    };
    status: number; // 409
  };
};
type VersionAlreadyPresentInDynamoError = {
  message: string; // Version already exists
  data: {
    code: NCS_ERROR_CODE.VERSION_NUMBER_ALREADY_EXISTS;
    meta: string; // Incoming version number already exists. Therefore, new ProseMirror steps will be rejected.
    status: number; // 409
  };
};
// - Permission errors
type InsufficientEditingPermissionError = {
  message: string; // No permission
  data: {
    code: NCS_ERROR_CODE.INSUFFICIENT_EDITING_PERMISSION;
    meta: {
      description: string; // The user does not have permission for collaborative editing of this resource or the resource was deleted
      reason?: string; // Usually empty
    };
    status: number; // 401
  };
};
type ForbiddenUserTokenError = {
  message: string; // Various issues with the user context token
  data: {
    code: NCS_ERROR_CODE.FORBIDDEN_USER_TOKEN;
    meta: string; // Forbidden to access pass due to invalid user token
    status: number; // 403
  };
};
// - Page missing / TTL errors
type NCSDocumentNotFoundError = {
  message: string; // The requested document is not found
  data: {
    code: NCS_ERROR_CODE.DOCUMENT_NOT_FOUND;
    status: number; // 404
  };
};
// - Server errors
type FailedToLoadInitDataError = {
  message: string; // Failed to load initialisation data after connection established
  data: {
    code: NCS_ERROR_CODE.INIT_DATA_LOAD_FAILED;
    status: number; // 500
  };
};
type ErrorMappingError = {
  message: string; // 'Internal Server Error'
  data: {
    code: NCS_ERROR_CODE.ERROR_MAPPING_ERROR;
    status: number; // 500
  };
};
// - Less common back-end errors
type InvalidNamespaceDefinedError = {
  message: string;
  data: {
    code: NCS_ERROR_CODE.NAMESPACE_INVALID;
    meta: string;
    status: number; // 400
  };
};
type SocketNamespaceNotFoundError = {
  message: string;
  data: {
    code: NCS_ERROR_CODE.NAMESPACE_NOT_FOUND;
    meta: string;
    status: number; // 500
  };
};
type TenantInstanceMaintenanceError = {
  message: string;
  data: {
    code: NCS_ERROR_CODE.TENANT_INSTANCE_MAINTENANCE;
    meta: {
      description: string;
      reason: string;
    };
    status: number; // 423
  };
};
type NamespaceLockedError = {
  message: string;
  data: {
    code: NCS_ERROR_CODE.LOCKED_DOCUMENT;
    meta: string;
    status: number; // 400
  };
};
type EmptyBroadcastError = {
  message: string;
  data: {
    code: NCS_ERROR_CODE.EMPTY_BROADCAST;
    meta: string;
    status: number; // 400
  };
};
type DynamoError = {
  message: string; // Error while updating metadata
  data: {
    code: NCS_ERROR_CODE.DYNAMO_ERROR;
    meta: string; // No value returned from metadata while updating
    status: number; // 500
  };
};
type InvalidActivationIdError = {
  message: string;
  data: {
    code: NCS_ERROR_CODE.INVALID_ACTIVATION_ID;
    meta: string;
    status: number; // 400
  };
};
type InvalidDocumentAriError = {
  message: string;
  data: {
    code: NCS_ERROR_CODE.INVALID_DOCUMENT_ARI;
    meta: string;
    status: number; // 400
  };
};
type InvalidCloudIdError = {
  message: string;
  data: {
    code: NCS_ERROR_CODE.INVALID_CLOUD_ID;
    meta: string;
    status: number; // 401
  };
};
type NCSErrors =
  | HeadVersionUpdateFailedError
  | VersionAlreadyPresentInDynamoError
  | InsufficientEditingPermissionError
  | ForbiddenUserTokenError
  | NCSDocumentNotFoundError
  | FailedToLoadInitDataError
  | ErrorMappingError
  | InvalidNamespaceDefinedError
  | SocketNamespaceNotFoundError
  | TenantInstanceMaintenanceError
  | NamespaceLockedError
  | EmptyBroadcastError
  | DynamoError
  | InvalidActivationIdError
  | InvalidDocumentAriError
  | InvalidCloudIdError;

// Provider Errors
type DocumentRecoveryError = {
  message: string;
  data: {
    code: INTERNAL_ERROR_CODE.DOCUMENT_RESTORE_ERROR;
    status: number; // 500
  };
};
type AddStepsError = {
  message: string;
  data: {
    code: INTERNAL_ERROR_CODE.ADD_STEPS_ERROR;
    status: number; // 500
  };
};

// Channel Errors
export type CatchUpFailedError = {
  message: string;
  data: {
    code: INTERNAL_ERROR_CODE.CATCHUP_FAILED;
    status: number; // ?
  };
};
export type TokenPermissionError = {
  message: string; // 'Insufficient editing permissions'
  data: {
    code: INTERNAL_ERROR_CODE.TOKEN_PERMISSION_ERROR;
    status: number; // 403
    meta: {
      originalError?: unknown;
      reason?: string; // RESOURCE_DELETED
    };
  };
};
export type ReconnectionError = {
  message: string; // 'Caught error during reconnection'
  data: {
    code: INTERNAL_ERROR_CODE.RECONNECTION_ERROR;
    status: number; // 500
  };
};
export type ConnectionError = {
  message: string;
  data: {
    code: INTERNAL_ERROR_CODE.CONNECTION_ERROR;
    // some error data stuff
  };
};
export type ReconnectionNetworkError = {
  message: string; // Reconnection failed 8 times when browser was offline, likely there was a network issue
  data: {
    code: INTERNAL_ERROR_CODE.RECONNECTION_NETWORK_ISSUE;
  };
};
export type DocumentNotFoundError = {
  message: string; // The requested document is not found
  data: {
    code: INTERNAL_ERROR_CODE.DOCUMENT_NOT_FOUND;
    status: number; // 404
  };
};

/**
 * A union of all possible internal errors, that are mapped to another error if being emitted to the editor.
 */
export type InternalError =
  | NCSErrors
  | DocumentRecoveryError
  | AddStepsError
  | CatchUpFailedError
  | TokenPermissionError
  | ReconnectionError
  | ConnectionError
  | ReconnectionNetworkError
  | DocumentNotFoundError;

// Emitted errors
export enum PROVIDER_ERROR_CODE {
  NO_PERMISSION_ERROR = 'NO_PERMISSION_ERROR',
  INVALID_USER_TOKEN = 'INVALID_USER_TOKEN',
  DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND',
  LOCKED = 'LOCKED',
  FAIL_TO_SAVE = 'FAIL_TO_SAVE',
  DOCUMENT_RESTORE_ERROR = 'DOCUMENT_RESTORE_ERROR',
  INITIALISATION_ERROR = 'INITIALISATION_ERROR',
  NETWORK_ISSUE = 'NETWORK_ISSUE',
  INVALID_PROVIDER_CONFIGURATION = 'INVALID_PROVIDER_CONFIGURATION',
  INTERNAL_SERVICE_ERROR = 'INTERNAL_SERVICE_ERROR',
}

/*
 * This is what a generic ProviderError type would look like:
 * type ProviderError = {
 *   // Unique code, identifies the specific emitted error
 *   // Also exposed as a PROVIDER_ERROR_CODE enum to allow subscribers to use them
 *   code: PROVIDER_ERROR_CODE;
 *   // Informative message describing what went wrong
 *   message: string;
 *   // Flag indicating whether an error is recoverable or not
 *   // used by consumers to disable the provider and show an error message
 *   recoverable: boolean;
 *   // A reason code used to give more detail about why a certain error was thrown
 *   reason?: string;
 * }
 */

/**
 * This occurs when the provided user token is considered invalid for the given document ARI.
 * It happens during initialisation of the provider.
 * It could mean the document has been deleted (hence not found).
 * @message Message returned to editor, i.e User does not have permissions to access this document or document is not found
 * @recoverable It is recoverable, as we will try to refresh the token.
 */
type InsufficientEditingPermission = {
  code: PROVIDER_ERROR_CODE.NO_PERMISSION_ERROR;
  message: string;
  recoverable: boolean;
  reason?: string;
  /**
   * @deprecated switch to using either the error code or the recoverable flag
   */
  status?: number;
};

/**
 * Similiar to InsufficientEditingPermission, but the user token is invalid because it has expired or been revoked.
 * It may also be an invalid token format.
 * This error is given to the provider by NCS.
 * @message Message returned to editor, i.e. The user token was invalid
 * @recoverable It is recoverable, as we will try to refresh the token.
 */
type InvalidUserToken = {
  code: PROVIDER_ERROR_CODE.INVALID_USER_TOKEN;
  message: string;
  recoverable: boolean;
  /**
   * @deprecated switch to using either the error code or the recoverable flag
   */
  status?: number;
};

/**
 * Document not found error, thrown when the provider is unable to find a document with the given ARI and user token.
 * It occurs during fetchCatchup, a function that fetches the latest document state during catchup.
 * We need to recieve a 404 from the document service to throw this error.
 * @message Message returned to editor, i.e. The requested document is not found
 * @recoverable It is recoverable, as the provider can try again later.
 */
type DocumentNotFound = {
  code: PROVIDER_ERROR_CODE.DOCUMENT_NOT_FOUND;
  message: string;
  recoverable: boolean;
  /**
   * @deprecated switch to using either the error code or the recoverable flag
   */
  status?: number;
};

/**
 * This error is thrown when the document is locked by another user.
 * The error is passed to us by NCS.
 * @message Message returned to editor, i.e. The document is currently not available, please try again later
 * @recoverable It is recoverable, as the provider can try again later.
 */
type Locked = {
  code: PROVIDER_ERROR_CODE.LOCKED;
  message: string;
  recoverable: boolean;
  status?: number;
};

/**
 * This error is thrown when the provider is unable to save the document.
 * This can happen when the connection to dynamoDB is lost, or when we do not have sufficient permissions (DYNAMO ERROR).
 * This error is given to us by NCS.
 * @message Message returned to editor, i.e. Collab service is not able to save changes
 * @recoverable It is not recoverable, as we don't want the user to continue editing a document that is not being saved.
 */
type FailToSave = {
  code: PROVIDER_ERROR_CODE.FAIL_TO_SAVE;
  message: string;
  recoverable: boolean;
  /**
   * @deprecated switch to using either the error code or the recoverable flag
   */
  status?: number;
};

/**
 * This error is thrown when the provider is unable to restore the document.
 * It occurs during onRestore, a function that restores the document to a previous version and reapplies unconfirmed steps.
 * onRestore is called when page recovery has emitted an 'init' event on a page client is currently connected to.
 * It could mean we failed to update the page metadata, or we failed to reapply unconfirmed steps.
 * @message Message returned to editor, i.e. Collab service unable to restore document
 * @recoverable It is not recoverable, as the provider has no further options after this.
 * The user will need to refresh the page to try again.
 */
type DocumentNotRestore = {
  code: PROVIDER_ERROR_CODE.DOCUMENT_RESTORE_ERROR;
  message: string;
  recoverable: boolean;
  /**
   * @deprecated switch to using either the error code or the recoverable flag
   */
  status?: number;
};

/**
 * The initial document couldn't be loaded from the collab service.
 * This error is given to us by NCS.
 * It could indicate either a network issue, or an internal service error in NCS.
 * @message Message returned to editor, i.e. The initial document couldn't be loaded from the collab service
 * @recoverable It is not recoverable, as the provider cannot do anything to fix it.
 * The user will need to refresh the page to try again.
 */
type InitialisationError = {
  code: PROVIDER_ERROR_CODE.INITIALISATION_ERROR;
  message: string;
  recoverable: boolean;
  /**
   * @deprecated switch to using either the error code or the recoverable flag
   */
  status?: number;
};

/**
 * Couldn't reconnect to the collab service (NCS) due to network issues.
 * NCS could be down, or the user could be offline. It's also possible the url is incorrect, or the user is behind a proxy blocking the connection.
 * Fired upon a reconnection attempt error (from Socket.IO Manager)
 * @message Message returned to editor, i.e. Couldn't reconnect to the collab service due to network issues
 * @recoverable It is recoverable, as the provider will try to reconnect.
 */
type NetworkIssue = {
  code: PROVIDER_ERROR_CODE.NETWORK_ISSUE;
  message: string;
  recoverable: boolean;
  /**
   * @deprecated switch to using either the error code or the recoverable flag
   */
  status?: number;
};

/**
 * This error is thrown when the provider has an invalid configuration.
 * It could happen due to these errors from NCS:
 *  NAMESPACE_INVALID
    INVALID_ACTIVATION_ID
    INVALID_DOCUMENT_ARI
    INVALID_CLOUD_ID
 * @message Message returned to editor, i.e. Invalid provider configuration
 * @recoverable It is not recoverable, as the provider cannot do anything to fix it.
 * The service using the provider will need to fix the configuration.
 */
type InvalidProviderConfiguration = {
  code: PROVIDER_ERROR_CODE.INVALID_PROVIDER_CONFIGURATION;
  message: string;
  recoverable: boolean;
  reason: string;
  /**
   * @deprecated switch to using either the error code or the recoverable flag
   */
  status?: number;
};

/**
 * This error is thrown when the provider encounters an internal service error, not otherwise accounted for.
 * @message Message returned to editor, i.e. Collab Provider experienced an unrecoverable error
 * @recoverable It is not recoverable, as the provider cannot do anything to fix it.
 */
type InternalServiceError = {
  code: PROVIDER_ERROR_CODE.INTERNAL_SERVICE_ERROR;
  message: string;
  recoverable: boolean;
  reason: string;
  /**
   * @deprecated switch to using either the error code or the recoverable flag
   */
  status?: number;
};

/**
 * A union of all possible provider errors that can be emitted back to the editor.
 */
export type ProviderError =
  | InsufficientEditingPermission
  | InvalidUserToken
  | DocumentNotFound
  | Locked
  | FailToSave
  | DocumentNotRestore
  | InitialisationError
  | NetworkIssue
  | InvalidProviderConfiguration
  | InternalServiceError;

// Custom Errors
class CustomError extends Error {
  constructor(message: string, error?: unknown) {
    super(message);

    if (typeof (error as Error)?.message === 'string') {
      this.message = (error as Error).message;
    }
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
    };
  }
}

export class NotConnectedError extends CustomError {
  name = 'NotConnectedError';
}

export class NotInitializedError extends CustomError {
  name = 'NotInitializedError';
}

export class ProviderInitialisationError extends CustomError {
  name = 'ProviderInitialisationError';
}

export class SendTransactionError extends CustomError {
  name = 'SendTransactionError';
}

export class DestroyError extends CustomError {
  name = 'DestroyError';
}

export class SetTitleError extends CustomError {
  name = 'SetTitleError';
}

export class SetEditorWidthError extends CustomError {
  name = 'SetEditorWidthError';
}

export class SetMetadataError extends CustomError {
  name = 'SetMetadataError';
}

export class GetCurrentStateError extends CustomError {
  name = 'GetCurrentStateError';
}

export class GetFinalAcknowledgedStateError extends CustomError {
  name = 'GetFinalAcknowledgedStateError';
}
