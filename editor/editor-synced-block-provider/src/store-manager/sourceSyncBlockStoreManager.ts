import uuid from 'uuid';

import { type Node as PMNode } from '@atlaskit/editor-prosemirror/model';
import type { EditorState, Transaction } from '@atlaskit/editor-prosemirror/state';
import type { EditorView } from '@atlaskit/editor-prosemirror/view';

import { rebaseTransaction } from '../common/rebase-transaction';
import type {
	BlockInstanceId,
	SyncBlockAttrs,
	SyncBlockData,
	SyncBlockNode,
} from '../common/types';
import type { SyncBlockDataProvider } from '../providers/types';
import { resourceIdFromSourceAndLocalId } from '../utils/ari';
import { convertSyncBlockPMNodeToSyncBlockData } from '../utils/utils';

export type ConfirmationCallback = () => Promise<boolean>;

export class SourceSyncBlockStoreManager {
	private dataProvider?: SyncBlockDataProvider;
	private editorView?: EditorView;

	private syncBlockCache: Map<BlockInstanceId, SyncBlockData>;

	private confirmationCallback?: ConfirmationCallback;
	private confirmationTransaction?: Transaction;

	constructor(dataProvider?: SyncBlockDataProvider) {
		this.dataProvider = dataProvider;
		this.syncBlockCache = new Map();
	}

	/**
	 * Add/update a sync block node to/from the local cache
	 * @param syncBlockNode - The sync block node to update
	 */
	public updateSyncBlockData(syncBlockNode: PMNode) {
		try {
			const { localId, resourceId } = syncBlockNode.attrs;

			if (!localId || !resourceId) {
				throw new Error('Local ID or resource ID is not set');
			}

			const syncBlockData = convertSyncBlockPMNodeToSyncBlockData(syncBlockNode);
			this.syncBlockCache.set(localId, syncBlockData);
		} catch {
			//TODO: EDITOR-1921 - add error analytics
		}
	}

	/**
	 * Save content of bodiedSyncBlock nodes in local cache to backend
	 *
	 * @returns true if saving all nodes successfully, false if fail to save some/all nodes
	 */
	public async flushBodiedSyncBlocks(): Promise<boolean> {
		try {
			if (!this.dataProvider) {
				throw new Error('Data provider not set');
			}

			const bodiedSyncBlockNodes: SyncBlockNode[] = [];
			const bodiedSyncBlockData: SyncBlockData[] = [];

			Array.from(this.syncBlockCache.values()).forEach((syncBlockData) => {
				bodiedSyncBlockNodes.push({
					type: 'bodiedSyncBlock',
					attrs: {
						localId: syncBlockData.blockInstanceId,
						resourceId: syncBlockData.resourceId,
					},
				});
				bodiedSyncBlockData.push(syncBlockData);
			});

			if (bodiedSyncBlockNodes.length === 0) {
				return Promise.resolve(true);
			}

			const resourceIds = await this.dataProvider.writeNodesData(
				bodiedSyncBlockNodes,
				bodiedSyncBlockData,
			);
			return resourceIds.every((resourceId) => resourceId !== undefined);
		} catch {
			//TODO: EDITOR-1921 - add error analytics
			return false;
		}
	}

	public setEditorView(editorView: EditorView | undefined) {
		this.editorView = editorView;
	}

	public registerConfirmationCallback(callback: ConfirmationCallback) {
		this.confirmationCallback = callback;

		return () => {
			this.confirmationCallback = undefined;
		};
	}

	public requireConfirmationBeforeDelete(): boolean {
		return !!this.confirmationCallback;
	}

	public createSyncBlockNode(): SyncBlockNode {
		const blockInstanceId = uuid();
		const sourceId = this.dataProvider?.getSourceId();
		if (!sourceId) {
			throw new Error('Provider of sync block plugin is not set');
		}

		// This should be generated by the data provider implementation as it differs between data providers
		const resourceId = resourceIdFromSourceAndLocalId(sourceId, blockInstanceId);
		const syncBlockNode: SyncBlockNode = {
			attrs: {
				resourceId,
				localId: blockInstanceId,
			},
			type: 'bodiedSyncBlock',
		};
		return syncBlockNode;
	}

	public async deleteSyncBlocksWithConfirmation(
		tr: Transaction,
		syncBlockIds: SyncBlockAttrs[],
	): Promise<void> {
		if (this.confirmationCallback) {
			this.confirmationTransaction = tr;
			const confirmed = await this.confirmationCallback();
			if (confirmed) {
				this.editorView?.dispatch(
					this.confirmationTransaction.setMeta('isConfirmedSyncBlockDeletion', true),
				);
				// Need to update the BE on deletion
				syncBlockIds.forEach(({ localId }) => this.syncBlockCache.delete(localId));
			}
			this.confirmationTransaction = undefined;
		}
	}

	public rebaseTransaction(incomingTr: Transaction, state: EditorState): void {
		if (!this.confirmationTransaction) {
			return;
		}

		this.confirmationTransaction = rebaseTransaction(
			this.confirmationTransaction,
			incomingTr,
			state,
		);
	}
}
