<!-- API Report Version: 2.3 -->

## API Report File for "@atlaskit/emoji"

> Do not edit this file. This report is auto-generated using
> [API Extractor](https://api-extractor.com/).
> [Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

### Table of contents

- [Main Entry Types](#main-entry-types)
- [Peer Dependencies](#peer-dependencies)

### Main Entry Types

<!--SECTION START: Main Entry Types-->

```ts
/// <reference types="react" />

import { AbstractResource } from '@atlaskit/util-service-support';
import { Component } from 'react';
import type { ComponentClass } from 'react';
import { ComponentType } from 'react';
import { ConcurrentExperience } from '@atlaskit/ufo';
import { CreateUIAnalyticsEvent } from '@atlaskit/analytics-next';
import { FC } from 'react';
import { ForwardRefExoticComponent } from 'react';
import { jsx } from '@emotion/react';
import type { Provider } from '@atlaskit/util-service-support/types';
import { PureComponent } from 'react';
import { default as React_2 } from 'react';
import { RefAttributes } from 'react';
import { ServiceConfig } from '@atlaskit/util-service-support';
import type { SyntheticEvent } from 'react';
import { UFOExperience } from '@atlaskit/ufo';
import { WithAnalyticsEventsProps } from '@atlaskit/analytics-next';

export { AbstractResource };

// @public (undocumented)
export interface AltRepresentations {
	// (undocumented)
	[key: string]: EmojiServiceRepresentation;
}

// @public (undocumented)
interface BaseResourcedEmojiProps {
	customFallback?: JSX.Element | string;
	emojiId: EmojiId;
	fitToHeight?: number;
	optimistic?: boolean;
	optimisticImageURL?: string;
	showTooltip?: boolean;
}

// @public (undocumented)
export interface CategoryDescription {
	// (undocumented)
	icon: any;
	// (undocumented)
	id: string;
	// (undocumented)
	name: keyof typeof messages;
	// (undocumented)
	order: number;
}

// @public (undocumented)
export type CategoryId =
	| 'ACTIVITY'
	| 'ATLASSIAN'
	| 'CUSTOM'
	| 'FLAGS'
	| 'FOODS'
	| 'FREQUENT'
	| 'NATURE'
	| 'OBJECTS'
	| 'PEOPLE'
	| 'PLACES'
	| 'SYMBOLS';

// @public (undocumented)
export const customCategory = 'CUSTOM';

// @public (undocumented)
export const defaultEmojiHeight = 20;

// @public
export const denormaliseEmojiServiceResponse: (emojiData: EmojiServiceResponse) => EmojiResponse;

// @public
class DuplicateLimitedQueue<T> {
	constructor(options: QueueOptions);
	protected bulkEnqueue(items: T[]): void;
	clear(): void;
	// (undocumented)
	enqueue(item: T): void;
	protected getItems(): T[];
	getItemsOrderedByDuplicateCount(): Array<T>;
}

// @public (undocumented)
export const Emoji: (props: Props) => jsx.JSX.Element;

// @public
export const EmojiCommonProvider: FC<EmojiCommonProviderProps>;

// @public (undocumented)
interface EmojiCommonProviderProps {
	emojiProvider?: EmojiProvider;
}

// @public (undocumented)
interface EmojiContext {
	// (undocumented)
	emoji: {
		emojiProvider: EmojiProvider;
	};
}

// @public (undocumented)
export const EmojiContextProvider: FC<EmojiContextProviderType>;

// @public (undocumented)
type EmojiContextProviderType = {
	emojiContextValue: EmojiContextType;
};

// @public (undocumented)
type EmojiContextType = EmojiContext | null;

// @public (undocumented)
export interface EmojiDescription extends EmojiId {
	// (undocumented)
	altRepresentation?: EmojiRepresentation;
	// (undocumented)
	ascii?: string[];
	// (undocumented)
	category: string;
	// (undocumented)
	createdDate?: string;
	// (undocumented)
	creatorUserId?: string;
	// (undocumented)
	name?: string;
	// (undocumented)
	order?: number;
	// (undocumented)
	representation: EmojiRepresentation;
	// (undocumented)
	searchable: boolean;
	// (undocumented)
	type: string;
}

// @public (undocumented)
export interface EmojiDescriptionWithVariations extends EmojiDescription {
	// (undocumented)
	skinVariations?: EmojiDescription[];
}

// @public
export interface EmojiId {
	// (undocumented)
	fallback?: string;
	// (undocumented)
	id?: string;
	// (undocumented)
	shortName: string;
}

// @public (undocumented)
export const emojiImage = 'emoji-common-emoji-image';

// @public (undocumented)
export interface EmojiImageRepresentation {
	// (undocumented)
	height: number;
	// (undocumented)
	width: number;
}

// @public
export class EmojiLoader {
	constructor(config: EmojiLoaderConfig);
	loadEmoji(): Promise<EmojiResponse>;
}

// @public (undocumented)
interface EmojiLoaderConfig extends ServiceConfig {
	// (undocumented)
	getRatio?: () => number;
}

// @public (undocumented)
export interface EmojiMeta {
	// (undocumented)
	mediaApiToken?: MediaApiToken;
	// (undocumented)
	spriteSheets?: SpriteSheets;
}

// @public (undocumented)
export const emojiNode = 'emoji-common-node';

// @public (undocumented)
const EmojiPicker: ForwardRefExoticComponent<
	Pick<
		Omit<Props_3 & WithAnalyticsEventsProps, keyof WithAnalyticsEventsProps>,
		'emojiProvider' | 'hideToneSelector' | 'onPickerRef' | 'onSelection'
	> &
		Partial<
			Pick<Omit<Props_3 & WithAnalyticsEventsProps, keyof WithAnalyticsEventsProps>, 'size'>
		> &
		Partial<
			Pick<
				{
					size: string;
				},
				never
			>
		> &
		RefAttributes<any>
>;
export { EmojiPicker };
export default EmojiPicker;

// @public (undocumented)
export const emojiPickerHeight = 295;

// @public (undocumented)
export const emojiPickerWidth = 350;

// @public (undocumented)
export const EmojiPlaceholder: (props: Props_2) => jsx.JSX.Element;

// @public (undocumented)
export const emojiPlaceholder = 'emoji-common-placeholder';

// @public (undocumented)
interface EmojiProgessCallback {
	// (undocumented)
	(progress: EmojiProgress): void;
}

// @public (undocumented)
interface EmojiProgress {
	// (undocumented)
	readonly percent: number;
}

// @public (undocumented)
export interface EmojiProvider
	extends Provider<string, EmojiSearchResult, any, undefined, SearchOptions> {
	calculateDynamicCategories?(): Promise<string[]>;
	deleteSiteEmoji(emoji: EmojiDescription): Promise<boolean>;
	fetchByEmojiId(
		emojiId: EmojiId,
		optimistic: boolean,
	): OptionalEmojiDescriptionWithVariations | Promise<OptionalEmojiDescriptionWithVariations>;
	fetchEmojiProvider(force?: boolean): Promise<EmojiRepository | undefined>;
	findByEmojiId(emojiId: EmojiId): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
	findById(id: string): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
	findByShortName(shortName: string): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
	findInCategory(categoryId: string): Promise<EmojiDescription[]>;
	getAsciiMap(): Promise<Map<string, EmojiDescription>>;
	getCurrentUser(): OptionalUser;
	getFrequentlyUsed(options?: SearchOptions): Promise<EmojiDescription[]>;
	getMediaEmojiDescriptionURLWithInlineToken(emoji: EmojiDescription): Promise<EmojiDescription>;
	getOptimisticImageURL(emojiId: EmojiId): string | undefined;
	getSelectedTone(): ToneSelection;
	loadMediaEmoji(
		emoji: EmojiDescription,
		useAlt?: boolean,
	): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
	onlyFetchOnDemand?(): boolean;
	optimisticMediaRendering(emoji: EmojiDescription, useAlt?: boolean): boolean;
	recordSelection?(emoji: EmojiDescription): Promise<any>;
	setSelectedTone(tone: ToneSelection): void;
}

// @public (undocumented)
export class EmojiRepository {
	constructor(emojis: EmojiDescription[], usageTracker?: UsageFrequencyTracker);
	// (undocumented)
	addUnknownEmoji(emoji: EmojiDescription): void;
	all(): EmojiSearchResult;
	// (undocumented)
	delete(emoji: EmojiDescription): void;
	findAllMatchingShortName(shortName: string): EmojiDescription[];
	// (undocumented)
	findByAsciiRepresentation(asciiEmoji: string): OptionalEmojiDescription;
	findById(id: string): OptionalEmojiDescription;
	findByShortName(shortName: string): OptionalEmojiDescription;
	// (undocumented)
	findInCategory(categoryId: CategoryId): EmojiDescription[];
	// (undocumented)
	getAsciiMap(): Map<string, EmojiDescription>;
	// (undocumented)
	getDynamicCategoryList(): CategoryId[];
	getFrequentlyUsed(options?: SearchOptions): EmojiDescription[];
	search(query?: string, options?: SearchOptions): EmojiSearchResult;
	// (undocumented)
	protected usageTracker: UsageFrequencyTracker;
	used(emoji: EmojiDescription): void;
}

// @public (undocumented)
export type EmojiRepresentation =
	| ImageRepresentation
	| MediaApiRepresentation
	| SpriteRepresentation
	| undefined;

// @public (undocumented)
export class EmojiResource extends EmojiResource_2 implements UploadingEmojiProvider {
	constructor(config: EmojiResourceConfig);
	// (undocumented)
	protected allowUpload: boolean;
	// (undocumented)
	isUploadSupported(): Promise<boolean>;
	// (undocumented)
	prepareForUpload(): Promise<void>;
	// (undocumented)
	uploadCustomEmoji(upload: EmojiUpload, retry?: boolean): Promise<EmojiDescription>;
}

// @public (undocumented)
class EmojiResource_2
	extends AbstractResource<string, EmojiSearchResult, any, undefined, SearchOptions>
	implements EmojiProvider
{
	constructor(config: EmojiResourceConfig);
	// (undocumented)
	protected activeLoaders: number;
	// (undocumented)
	protected addUnknownEmoji(emoji: EmojiDescription): void;
	// (undocumented)
	calculateDynamicCategories(): Promise<CategoryId[]>;
	// (undocumented)
	protected currentUser?: User;
	// (undocumented)
	deleteSiteEmoji(emoji: EmojiDescription): Promise<boolean>;
	// (undocumented)
	emojiProviderConfig: EmojiResourceConfig;
	// (undocumented)
	protected emojiRepository?: EmojiRepository;
	// (undocumented)
	protected emojiResponses: EmojiResponse[];
	// (undocumented)
	fetchByEmojiId(
		emojiId: EmojiId,
		optimistic: boolean,
	): Promise<OptionalEmojiDescriptionWithVariations>;
	// (undocumented)
	fetchEmojiProvider(force?: boolean): Promise<EmojiRepository | undefined>;
	// (undocumented)
	protected fetchOnDemand: boolean;
	// (undocumented)
	filter(query?: string, options?: SearchOptions): void;
	// (undocumented)
	findByEmojiId(emojiId: EmojiId): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
	// (undocumented)
	findById(id: string): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
	// (undocumented)
	findByShortName(shortName: string): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
	// (undocumented)
	findInCategory(categoryId: CategoryId): Promise<EmojiDescription[]>;
	// (undocumented)
	getAsciiMap(): Promise<Map<string, EmojiDescription>>;
	// (undocumented)
	getCurrentUser(): OptionalUser;
	getEmojiProvider(options?: GetEmojiProviderOptions): Promise<EmojiProvider>;
	// (undocumented)
	getFrequentlyUsed(options?: SearchOptions): Promise<EmojiDescription[]>;
	getMediaEmojiDescriptionURLWithInlineToken(emoji: EmojiDescription): Promise<EmojiDescription>;
	// (undocumented)
	getOptimisticImageURL: (emojiId: EmojiId) => string | undefined;
	// (undocumented)
	getSelectedTone(): ToneSelection;
	// (undocumented)
	protected initEmojiRepository(emojiResponses: EmojiResponse[]): void;
	// (undocumented)
	protected initialLoaders: number;
	// (undocumented)
	protected initSiteEmojiResource(
		emojiResponse: EmojiResponse,
		provider: ServiceConfig,
	): Promise<void>;
	// (undocumented)
	protected isInitialised: boolean;
	// (undocumented)
	protected isRepositoryAvailable: <T>(repository?: T | undefined) => repository is T;
	// (undocumented)
	protected lastQuery?: LastQuery;
	// (undocumented)
	loadMediaEmoji(
		emoji: EmojiDescription,
		useAlt?: boolean,
	): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
	// (undocumented)
	protected notifyResult(result: EmojiSearchResult): void;
	// (undocumented)
	onlyFetchOnDemand(): boolean;
	// (undocumented)
	optimisticMediaRendering(emoji: EmojiDescription, useAlt?: boolean): boolean;
	// (undocumented)
	protected recordConfig?: ServiceConfig;
	recordSelection(emoji: EmojiDescription): Promise<any>;
	// (undocumented)
	protected refreshLastFilter(): void;
	// (undocumented)
	protected retries: Map<Retry<any>, ResolveReject<any>>;
	// (undocumented)
	protected retryIfLoading<T>(retry: Retry<T>, defaultResponse: T): Promise<T>;
	// (undocumented)
	protected selectedTone: ToneSelection;
	// (undocumented)
	setSelectedTone(tone: ToneSelection): void;
	// (undocumented)
	protected siteEmojiResource?: SiteEmojiResource;
}

// @public (undocumented)
export interface EmojiResourceConfig {
	allowUpload?: boolean;
	currentUser?: User;
	optimisticImageApi?: OptimisticImageApiLoaderConfig;
	options?: Options;
	providers: ServiceConfig[];
	recordConfig?: ServiceConfig;
	singleEmojiApi?: SingleEmojiApiLoaderConfig;
}

// @public (undocumented)
export interface EmojiResponse {
	// (undocumented)
	emojis: EmojiDescriptionWithVariations[];
	// (undocumented)
	mediaApiToken?: MediaApiToken;
}

// @public (undocumented)
export interface EmojiSearchResult {
	// (undocumented)
	emojis: EmojiDescription[];
	// (undocumented)
	query?: string;
}

// @public (undocumented)
export interface EmojiServiceDescription {
	// (undocumented)
	altRepresentations?: AltRepresentations;
	// (undocumented)
	ascii?: string[];
	// (undocumented)
	category: string;
	// (undocumented)
	createdDate?: string;
	// (undocumented)
	creatorUserId?: string;
	// (undocumented)
	fallback?: string;
	// (undocumented)
	id: string;
	// (undocumented)
	name?: string;
	// (undocumented)
	order?: number;
	// (undocumented)
	representation: EmojiServiceRepresentation;
	// (undocumented)
	searchable: boolean;
	// (undocumented)
	shortName: string;
	// (undocumented)
	type: string;
}

// @public (undocumented)
export interface EmojiServiceDescriptionWithVariations extends EmojiServiceDescription {
	// (undocumented)
	skinVariations?: EmojiServiceDescription[];
}

// @public (undocumented)
export type EmojiServiceRepresentation = ImageRepresentation | SpriteServiceRepresentation;

// @public
export interface EmojiServiceResponse {
	// (undocumented)
	emojis: EmojiServiceDescriptionWithVariations[];
	// (undocumented)
	meta?: EmojiMeta;
}

// @public (undocumented)
export const emojiSprite = 'emoji-common-emoji-sprite';

// @public (undocumented)
export class EmojiTypeAhead extends LoadingEmojiComponent<Props_7, State> {
	constructor(props: Props_7);
	// (undocumented)
	asyncLoadComponent(): void;
	// (undocumented)
	static AsyncLoadedComponent?: ComponentClass<Props_8>;
	// (undocumented)
	chooseCurrentSelection: () => void;
	// (undocumented)
	count: () => number;
	// (undocumented)
	renderLoaded(
		loadedEmojiProvider: EmojiProvider,
		TypeAheadComponent: ComponentClass<Props_8>,
	): JSX.Element | null;
	// (undocumented)
	selectNext: () => void;
	// (undocumented)
	selectPrevious: () => void;
	// (undocumented)
	state: {
		asyncLoadedComponent: React_2.ComponentClass<Props_8, any> | undefined;
	};
}

// @public (undocumented)
interface EmojiTypeAheadBaseProps {
	// (undocumented)
	createAnalyticsEvent?: CreateUIAnalyticsEvent;
	listLimit?: number;
	onClose?: OnLifecycle;
	onOpen?: OnLifecycle;
	onSelection?: OnEmojiEvent;
	query?: string;
}

// @public (undocumented)
export class EmojiTypeAheadItem extends PureComponent<Props_11, {}> {
	// (undocumented)
	onEmojiMenuItemMouseMove: React_2.MouseEventHandler<HTMLDivElement>;
	// (undocumented)
	onEmojiSelected: React_2.MouseEventHandler<HTMLDivElement>;
	// (undocumented)
	render(): jsx.JSX.Element;
}

// @public (undocumented)
export interface EmojiUpload {
	// (undocumented)
	dataURL: string;
	// (undocumented)
	filename: string;
	// (undocumented)
	height: number;
	// (undocumented)
	name: string;
	// (undocumented)
	shortName: string;
	// (undocumented)
	width: number;
}

// @public (undocumented)
export type EmojiUploader = EmojiUploaderInternal;

// @public (undocumented)
export const EmojiUploader: React_2.ForwardRefExoticComponent<
	Omit<Props_5, keyof WithAnalyticsEventsProps> & React_2.RefAttributes<any>
>;

// @public (undocumented)
class EmojiUploaderInternal extends LoadingEmojiComponent<Props_5, State> {
	constructor(props: Props_5);
	// (undocumented)
	asyncLoadComponent(): void;
	// (undocumented)
	static AsyncLoadedComponent?: FC<Props_6>;
	// (undocumented)
	renderLoaded(loadedEmojiProvider: EmojiProvider, EmojiUploadComponent: FC<Props_6>): JSX.Element;
	// (undocumented)
	state: {
		asyncLoadedComponent: React_2.FC<Props_6> | undefined;
	};
}

// @public
export interface EmojiVariationDescription extends EmojiDescription {
	baseId: string;
}

// @public (undocumented)
interface GetEmojiProviderOptions {
	fetchAtStart?: boolean;
}

// @public (undocumented)
export interface ImageRepresentation extends EmojiImageRepresentation {
	// (undocumented)
	imagePath: string;
}

// @public (undocumented)
interface LastQuery {
	// (undocumented)
	options?: SearchOptions;
	// (undocumented)
	query?: string;
}

// @public
abstract class LoadingEmojiComponent<P extends Props_4, S extends State> extends Component<P, S> {
	constructor(props: P, state: S);
	// (undocumented)
	abstract asyncLoadComponent(): void;
	// (undocumented)
	componentDidMount(): void;
	// (undocumented)
	componentWillUnmount(): void;
	// (undocumented)
	render(): JSX.Element | null;
	// (undocumented)
	abstract renderLoaded(
		loadedEmojiProvider: EmojiProvider,
		asyncLoadedComponent: ComponentType<any>,
	): JSX.Element | null;
	// (undocumented)
	renderLoading(): JSX.Element | null;
	// (undocumented)
	protected setAsyncState(asyncLoadedComponent: ComponentType<any>): void;
	// (undocumented)
	UNSAFE_componentWillReceiveProps(nextProps: Readonly<P>): void;
}

// @public (undocumented)
export interface MediaApiRepresentation extends EmojiImageRepresentation {
	// (undocumented)
	mediaPath: string;
}

// @public
export interface MediaApiToken {
	// (undocumented)
	clientId: string;
	// (undocumented)
	collectionName: string;
	// (undocumented)
	expiresAt: number;
	// (undocumented)
	jwt: string;
	// (undocumented)
	url: string;
}

// @public (undocumented)
export type Message = React.ReactNode | string;

// @public (undocumented)
const messages: {
	deleteEmojiTooltip: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	deleteEmojiTooltipForScreenreader: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	deleteEmojiTitle: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	deleteEmojiDescription: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	deleteEmojiLabel: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	addCustomEmojiLabel: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiPlaceholder: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiNameAriaLabel: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiChooseFileTitle: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiChooseFileScreenReaderDescription: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiSelectSkinToneButtonAriaLabelText: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiSelectSkinToneListAriaLabelText: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiImageRequirements: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiPreviewTitle: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiPreview: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	addEmojiLabel: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	retryLabel: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	cancelLabel: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	searchPlaceholder: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	searchLabel: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	searchResultsStatus: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	searchResultsStatusSeeAll: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	categoriesSelectorLabel: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	categoriesSearchResults: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	frequentCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	peopleCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	natureCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	foodsCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	activityCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	placesCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	objectsCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	symbolsCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	flagsCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	productivityCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	userUploadsCustomCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	allUploadsCustomCategory: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	deleteEmojiFailed: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiInvalidImage: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiUploadFailed: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiImageTooBig: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiPickerTitle: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiPickerListPanel: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiPickerGrid: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	emojiButtonRoleDescription: {
		id: string;
		defaultMessage: string;
		description: string;
	};
	error: {
		id: string;
		defaultMessage: string;
		description: string;
	};
};

// @public (undocumented)
export interface OnCategory {
	// (undocumented)
	(categoryId: CategoryId | null): void;
}

// @public (undocumented)
export interface OnEmojiEvent<T = any> {
	// (undocumented)
	(emojiId: EmojiId, emoji: OptionalEmojiDescription, event?: SyntheticEvent<T>): void;
}

// @public (undocumented)
interface OnLifecycle {
	// (undocumented)
	(): void;
}

// @public (undocumented)
export interface OnToneSelected {
	// (undocumented)
	(variation: ToneValueType): void;
}

// @public (undocumented)
export interface OnToneSelectorCancelled {
	// (undocumented)
	(): void;
}

// @public (undocumented)
interface OptimisticImageApiLoaderConfig extends Omit<ServiceConfig, 'url'> {
	// (undocumented)
	getUrl: (emojiId: EmojiId) => string;
}

// @public (undocumented)
export type OptionalEmojiDescription = EmojiDescription | undefined;

// @public (undocumented)
export type OptionalEmojiDescriptionWithVariations = EmojiDescriptionWithVariations | undefined;

// @public (undocumented)
export type OptionalUser = User | undefined;

// @public (undocumented)
interface Options {
	// (undocumented)
	onlyFetchOnDemand?: boolean;
}

// @public (undocumented)
interface PickerRefHandler {
	// (undocumented)
	(ref: any): any;
}

// @public (undocumented)
export type PickerSize = 'large' | 'medium' | 'small';

// @public (undocumented)
interface Props extends Omit<React_2.HTMLAttributes<HTMLSpanElement>, 'onFocus' | 'onMouseMove'> {
	autoWidth?: boolean;
	className?: string;
	disableLazyLoad?: boolean;
	emoji: EmojiDescription;
	fitToHeight?: number;
	onDelete?: OnEmojiEvent;
	onFocus?: OnEmojiEvent;
	onLoadError?: OnEmojiEvent<HTMLImageElement>;
	onLoadSuccess?: (emoji: EmojiDescription) => void;
	onMouseMove?: OnEmojiEvent;
	onSelected?: OnEmojiEvent;
	selected?: boolean;
	selectOnHover?: boolean;
	shouldBeInteractive?: boolean;
	showDelete?: boolean;
	showTooltip?: boolean;
}

// @public (undocumented)
interface Props_10 extends BaseResourcedEmojiProps {
	emojiProvider: Promise<EmojiProvider>;
}

// @public (undocumented)
interface Props_11 {
	// (undocumented)
	emoji: EmojiDescription;
	// (undocumented)
	emojiProvider?: EmojiProvider;
	// (undocumented)
	onMouseMove: OnEmojiEvent;
	// (undocumented)
	onSelection: OnEmojiEvent;
	// (undocumented)
	selected: boolean;
}

// @public (undocumented)
interface Props_2 {
	// (undocumented)
	loading?: boolean;
	// (undocumented)
	representation?: EmojiImageRepresentation;
	// (undocumented)
	shortName: string;
	// (undocumented)
	showTooltip?: boolean;
	// (undocumented)
	size?: number;
}

// @public (undocumented)
interface Props_3 extends Props_4 {
	hideToneSelector?: boolean;
	onPickerRef?: PickerRefHandler;
	onSelection?: OnEmojiEvent;
	size?: PickerSize;
}

// @public (undocumented)
interface Props_4 {
	emojiProvider: Promise<EmojiProvider>;
}

// @public (undocumented)
interface Props_5 extends Props_4 {
	// (undocumented)
	createAnalyticsEvent?: CreateUIAnalyticsEvent;
}

// @public (undocumented)
interface Props_6 {
	// (undocumented)
	createAnalyticsEvent?: CreateUIAnalyticsEvent;
	// (undocumented)
	emojiProvider: EmojiProvider;
	// (undocumented)
	onUploaderRef?: UploadRefHandler;
}

// @public (undocumented)
interface Props_7 extends EmojiTypeAheadBaseProps, Props_4 {
	// (undocumented)
	offsetX?: number;
	// (undocumented)
	offsetY?: number;
	// (undocumented)
	position?: RelativePosition;
	target?: HTMLElement | string;
	// (undocumented)
	zIndex?: number | string;
}

// @public (undocumented)
interface Props_8 extends EmojiTypeAheadBaseProps {
	emojiProvider: EmojiProvider;
}

// @public (undocumented)
interface Props_9 extends Props_10 {}

// @public
interface QueueOptions {
	maxDuplicates: number;
	minUniqueItems: number;
}

// @public (undocumented)
export const recordSelectionFailedSli: (options?: {
	createAnalyticsEvent?: CreateUIAnalyticsEvent;
}) => (err: Error) => Promise<never>;

// @public (undocumented)
export const recordSelectionSucceededSli: (options?: {
	createAnalyticsEvent?: CreateUIAnalyticsEvent;
}) => () => void;

// @public (undocumented)
export type RelativePosition = 'above' | 'auto' | 'below';

// @public (undocumented)
interface ResolveReject<T> {
	// (undocumented)
	reject(reason?: any): void;
	// (undocumented)
	resolve(result: T): void;
}

// @public (undocumented)
export const ResourcedEmoji: FC<Props_9>;

// @public (undocumented)
interface Retry<T> {
	// (undocumented)
	(): Promise<T> | T;
}

// @public (undocumented)
type SamplingFunc = (rate: number) => boolean;

// @public (undocumented)
export interface SearchOptions {
	// (undocumented)
	limit?: number;
	// (undocumented)
	skinTone?: number;
	// (undocumented)
	sort?: SearchSort;
	// (undocumented)
	source?: SearchSourceTypes;
}

// @public (undocumented)
export enum SearchSort {
	// (undocumented)
	Default = 1,
	// (undocumented)
	None = 0,
	// (undocumented)
	UsageFrequency = 2,
}

// @public (undocumented)
enum SearchSourceTypes {
	// (undocumented)
	PICKER = 'picker',
	// (undocumented)
	TYPEAHEAD = 'typeahead',
}

// @public (undocumented)
export const selected = 'emoji-common-selected';

// @public (undocumented)
export const selectOnHover = 'emoji-common-select-on-hover';

// @public (undocumented)
interface SingleEmojiApiLoaderConfig extends Omit<ServiceConfig, 'url'> {
	// (undocumented)
	getUrl: (emojiId: EmojiId) => string;
}

// @public (undocumented)
class SiteEmojiResource {
	constructor(siteServiceConfig: ServiceConfig, mediaApiToken: MediaApiToken);
	deleteEmoji(emoji: EmojiDescription): Promise<boolean>;
	// (undocumented)
	findEmoji(emojiId: EmojiId): Promise<OptionalEmojiDescription>;
	generateTokenisedMediaURLS(
		representation: EmojiRepresentation,
		altRepresentation?: EmojiRepresentation,
	): Promise<TokenisedEmojiRepresentation>;
	hasUploadToken(): Promise<boolean>;
	loadMediaEmoji(
		emoji: EmojiDescription,
		useAlt?: boolean,
	): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
	// (undocumented)
	optimisticRendering(emoji: EmojiDescription, useAlt?: boolean): Promise<boolean> | boolean;
	// (undocumented)
	prepareForUpload(): void;
	// (undocumented)
	protected tokenManager: TokenManager;
	// (undocumented)
	uploadEmoji(
		upload: EmojiUpload,
		retry?: boolean,
		progressCallback?: EmojiProgessCallback,
	): Promise<EmojiDescription>;
}

// @public (undocumented)
export interface SpriteImageRepresentation extends EmojiImageRepresentation {
	// (undocumented)
	x: number;
	// (undocumented)
	xIndex: number;
	// (undocumented)
	y: number;
	// (undocumented)
	yIndex: number;
}

// @public
export interface SpriteRepresentation extends SpriteImageRepresentation {
	// (undocumented)
	sprite: SpriteSheet;
}

// @public
export interface SpriteServiceRepresentation extends SpriteImageRepresentation {
	spriteRef: string;
}

// @public (undocumented)
export interface SpriteSheet {
	// (undocumented)
	column: number;
	// (undocumented)
	height: number;
	// (undocumented)
	row: number;
	// (undocumented)
	url: string;
	// (undocumented)
	width: number;
}

// @public (undocumented)
export interface SpriteSheets {
	// (undocumented)
	[index: string]: SpriteSheet;
}

// @public (undocumented)
interface State {
	// (undocumented)
	asyncLoadedComponent?: ComponentType<any>;
	// (undocumented)
	loadedEmojiProvider?: EmojiProvider;
}

// @public (undocumented)
export interface Styles {
	// (undocumented)
	[index: string]: any;
}

// @public (undocumented)
export const toEmojiId: (emoji: EmojiDescription) => EmojiId;

// @public (undocumented)
type TokenisedEmojiRepresentation = {
	representation?: EmojiRepresentation;
	altRepresentation?: EmojiRepresentation;
};

// @public (undocumented)
class TokenManager {
	constructor(siteServiceConfig: ServiceConfig);
	// (undocumented)
	addToken(type: TokenType, mediaApiToken: MediaApiToken): void;
	// (undocumented)
	fetchNewToken(type: TokenType): Promise<MediaApiToken>;
	// (undocumented)
	getToken(type: TokenType, forceRefresh?: boolean): Promise<MediaApiToken>;
	// (undocumented)
	isValidToken(mediaApiToken: MediaApiToken): boolean;
}

// @public (undocumented)
type TokenType = 'read' | 'upload';

// @public (undocumented)
export type ToneSelection = number | undefined;

// @public (undocumented)
type ToneValueType = number;

// @public (undocumented)
export const toOptionalEmojiId: (emoji: OptionalEmojiDescription) => EmojiId | undefined;

// @public (undocumented)
export enum UfoComponentName {
	// (undocumented)
	EMOJI = 'emoji',
	// (undocumented)
	EMOJI_PICKER = 'emoji-picker',
	// (undocumented)
	EMOJI_PROVIDER = 'emoji-provider',
}

// @public (undocumented)
export enum UfoExperienceName {
	// (undocumented)
	EMOJI_PICKER_OPENED = 'emoji-picker-opened',
	// (undocumented)
	EMOJI_RENDERED = 'emoji-rendered',
	// (undocumented)
	EMOJI_RESOURCE_FETCHED = 'emoji-resource-fetched',
	// (undocumented)
	EMOJI_SEARCHED = 'emoji-searched',
	// (undocumented)
	EMOJI_SELECTION_RECORDED = 'emoji-selection-recorded',
	// (undocumented)
	EMOJI_UPLOADED = 'emoji-uploaded',
}

// @public (undocumented)
export const ufoExperiences: {
	'emoji-rendered': ConcurrentExperience;
	'emoji-resource-fetched': ConcurrentExperience;
	'emoji-picker-opened': UFOExperience;
	'emoji-selection-recorded': UFOExperience;
	'emoji-uploaded': UFOExperience;
	'emoji-searched': UFOExperience;
};

// @public (undocumented)
export interface UploadingEmojiProvider extends EmojiProvider {
	isUploadSupported(): Promise<boolean>;
	prepareForUpload(): Promise<void>;
	uploadCustomEmoji(upload: EmojiUpload, retry?: boolean): Promise<EmojiDescription>;
}

// @public (undocumented)
interface UploadRefHandler {
	// (undocumented)
	(ref: HTMLDivElement): void;
}

// @public
export class UsageFrequencyTracker {
	constructor(useStorageIfPossible?: boolean);
	clear(): void;
	getOrder(): Array<string>;
	// (undocumented)
	protected queue: DuplicateLimitedQueue<string>;
	recordUsage(emoji: EmojiDescription): void;
}

// @public (undocumented)
export const useEmoji: () => {
	emojiProvider: EmojiProvider;
	isUploadSupported: boolean;
};

// @public @deprecated (undocumented)
export const useEmojiContext: () => EmojiContextType;

// @public (undocumented)
export interface User {
	// (undocumented)
	id: string;
}

// @public
export const withSampling: (ufoExperience: UFOExperience) => WithSamplingUFOExperience;

// @public (undocumented)
export interface WithSamplingUFOExperience extends Omit<UFOExperience, 'start'> {
	// (undocumented)
	start: (options: {
		samplingRate: number;
		samplingFunc?: SamplingFunc;
		startTime?: number;
	}) => Promise<void>;
}

// (No @packageDocumentation comment for this package)
```

<!--SECTION END: Main Entry Types-->

### Peer Dependencies

<!--SECTION START: Peer Dependencies-->

```json
{
	"react": "^16.8.0",
	"react-dom": "^16.8.0",
	"react-intl-next": "npm:react-intl@^5.18.1"
}
```

<!--SECTION END: Peer Dependencies-->
