<!-- API Report Version: 2.3 -->

## API Report File for "@atlaskit/media-client"

> Do not edit this file. This report is auto-generated using
> [API Extractor](https://api-extractor.com/).
> [Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

### Table of contents

- [Main Entry Types](#main-entry-types)
- [Peer Dependencies](#peer-dependencies)

### Main Entry Types

<!--SECTION START: Main Entry Types-->

```ts
import { AsapBasedAuth } from '@atlaskit/media-core';
import { Auth } from '@atlaskit/media-core';
import { AuthContext } from '@atlaskit/media-core';
import { AuthProvider } from '@atlaskit/media-core';
import { ChunkinatorFile } from '@atlaskit/chunkinator';
import { ClientAltBasedAuth } from '@atlaskit/media-core';
import { ErrorFileState } from '@atlaskit/media-state';
import { FilePreview } from '@atlaskit/media-state';
import { FileState } from '@atlaskit/media-state';
import { FileStatus as FileStatus_2 } from '@atlaskit/media-common';
import { LRUMap } from 'lru_map';
import { MediaApiConfig } from '@atlaskit/media-core';
import { MediaClientConfig } from '@atlaskit/media-core';
import { MediaFileArtifact } from '@atlaskit/media-state';
import { MediaFileArtifacts } from '@atlaskit/media-state';
import { MediaStore as MediaStore_2 } from '@atlaskit/media-state';
import { MediaTraceContext } from '@atlaskit/media-common';
import { MediaType } from '@atlaskit/media-common';
import { ProcessedFileState } from '@atlaskit/media-state';
import { ProcessingFailedState } from '@atlaskit/media-state';
import { ProcessingFileState } from '@atlaskit/media-state';
import { ReplaySubject } from 'rxjs/ReplaySubject';
import { UploadingFileState } from '@atlaskit/media-state';

// @public (undocumented)
export type AbortFunction = () => void;

// @public (undocumented)
export const addFileAttrsToUrl: (url: string, fileAttrs: MediaBlobUrlAttrs) => string;

// @public (undocumented)
export type AppendChunksToUploadRequestBody = {
	readonly chunks: string[];
	readonly hash?: string;
	readonly offset?: number;
};

// @public (undocumented)
export type Artifacts = {
	[name: string]: MediaArtifact;
};

// @public
abstract class BaseMediaClientError<Attributes extends MediaClientErrorAttributes>
	extends Error
	implements MediaClientError<Attributes>
{
	constructor(message: string);
	// (undocumented)
	abstract get attributes(): Attributes;
	// (undocumented)
	readonly message: string;
}

// @public (undocumented)
export const checkWebpSupport: () => Promise<boolean>;

// @public (undocumented)
export type ClientOptions = {
	readonly retryOptions?: Partial<RetryOptions>;
	readonly clientTimeout?: number;
};

// @public (undocumented)
type CompletionObserver = PartialObserver & Required<Pick<PartialObserver, 'complete'>>;

// @public (undocumented)
export interface CopyDestination extends MediaStoreCopyFileWithTokenParams {
	// (undocumented)
	authProvider: AuthProvider;
	// (undocumented)
	mediaStore?: MediaStore;
}

// @public (undocumented)
export interface CopyFileOptions {
	// (undocumented)
	mimeType?: string;
	// (undocumented)
	preview?: FilePreview | Promise<FilePreview>;
}

// @public (undocumented)
export interface CopySourceFile {
	// (undocumented)
	authProvider: AuthProvider;
	// (undocumented)
	collection?: string;
	// (undocumented)
	id: string;
}

// @public (undocumented)
export interface CreatedTouchedFile {
	// (undocumented)
	fileId: string;
	// (undocumented)
	uploadId: string;
}

// @public (undocumented)
export function createMediaSubject<T extends FileState>(initialState?: Error | T): ReplaySubject<T>;

// @public (undocumented)
export function createMediaSubscribable(item?: Error | FileState): MediaSubscribable;

// @public (undocumented)
export function createRequestErrorReason(statusCode: number): RequestErrorReason;

// @public (undocumented)
export function createUrl(url: string, { params, auth }: CreateUrlOptions): string;

// @public (undocumented)
export type CreateUrlOptions = {
	readonly params?: RequestParams;
	readonly auth?: Auth;
};

// @public (undocumented)
export type Dimensions = {
	width: number;
	height: number;
};

// @public (undocumented)
export interface EdgeData {
	// (undocumented)
	data: {
		clientId: string;
		token: string;
		baseUrl: string;
		expiresIn: number;
		iat: number;
	};
}

// @public (undocumented)
export interface EmptyFile {
	// (undocumented)
	readonly createdAt: number;
	// (undocumented)
	readonly id: string;
}

export { ErrorFileState };

// @public (undocumented)
type ErrorObserver = PartialObserver & Required<Pick<PartialObserver, 'error'>>;

// @public (undocumented)
export type EventPayloadListener<M extends EventPayloadMap<P>, E extends keyof M, P = any> = (
	payload: M[E],
) => void;

// @public (undocumented)
type EventPayloadMap<P> = {
	readonly [event: string]: P;
};

// @public (undocumented)
export type Executor = () => Promise<void>;

// @public (undocumented)
export interface ExternalImageIdentifier {
	// (undocumented)
	readonly dataURI: string;
	// (undocumented)
	readonly mediaItemType: 'external-image';
	// (undocumented)
	readonly name?: string;
}

// @public (undocumented)
type ExternalUploadPayload = {
	uploadableFileUpfrontIds: UploadableFileUpfrontIds;
	dimensions: Dimensions;
};

// @public (undocumented)
export interface FileDetails {
	// (undocumented)
	artifacts?: Artifacts;
	// (undocumented)
	createdAt?: number;
	// (undocumented)
	creationDate?: number;
	// (undocumented)
	id: string;
	// (undocumented)
	mediaType?: MediaType;
	// (undocumented)
	mimeType?: string;
	// (undocumented)
	name?: string;
	// (undocumented)
	processingStatus?: FileProcessingStatus;
	// (undocumented)
	size?: number;
}

// @public (undocumented)
export interface FileFetcher {
	// (undocumented)
	copyFile(
		source: CopySourceFile,
		destination: CopyDestination,
		options?: CopyFileOptions,
		traceContext?: MediaTraceContext,
	): Promise<MediaFile>;
	// (undocumented)
	downloadBinary(id: string, name?: string, collectionName?: string): Promise<void>;
	// (undocumented)
	getArtifactURL(
		artifacts: MediaFileArtifacts,
		artifactName: keyof MediaFileArtifacts,
		collectionName?: string,
	): Promise<string>;
	// (undocumented)
	getCurrentState(id: string, options?: GetFileOptions): Promise<FileState>;
	// (undocumented)
	getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
	// (undocumented)
	getFileState(id: string, options?: GetFileOptions): MediaSubscribable;
	// (undocumented)
	touchFiles(
		descriptors: TouchFileDescriptor[],
		collection?: string,
		traceContext?: MediaTraceContext,
	): Promise<TouchedFiles>;
	// (undocumented)
	upload(
		file: UploadableFile,
		controller?: UploadController,
		uploadableFileUpfrontIds?: UploadableFileUpfrontIds,
		traceContext?: MediaTraceContext,
	): MediaSubscribable;
	// (undocumented)
	uploadExternal(
		url: string,
		collection?: string,
		traceContext?: MediaTraceContext,
	): Promise<ExternalUploadPayload>;
}

// @public (undocumented)
export class FileFetcherError extends BaseMediaClientError<FileFetcherErrorAttributes> {
	constructor(
		reason: FileFetcherErrorReason,
		id: string,
		metadata?:
			| undefined
			| {
					readonly collectionName?: string | undefined;
					readonly occurrenceKey?: string | undefined;
			  },
	);
	// (undocumented)
	get attributes(): {
		reason: FileFetcherErrorReason;
		id: string;
		collectionName: string | undefined;
		occurrenceKey: string | undefined;
	};
	// (undocumented)
	readonly id: string;
	// (undocumented)
	readonly metadata?:
		| undefined
		| {
				readonly collectionName?: string | undefined;
				readonly occurrenceKey?: string | undefined;
		  };
	// (undocumented)
	readonly reason: FileFetcherErrorReason;
}

// @public (undocumented)
export type FileFetcherErrorAttributes = {
	readonly reason: FileFetcherErrorReason;
	readonly id: string;
	readonly metadata?: {
		readonly collectionName?: string;
		readonly occurrenceKey?: string;
	};
};

// @public (undocumented)
export type FileFetcherErrorReason =
	| 'emptyFileName'
	| 'emptyItems'
	| 'invalidFileId'
	| 'zeroVersionFile';

// @public (undocumented)
export class FileFetcherImpl implements FileFetcher {
	constructor(mediaApi: MediaStore, store?: MediaStore_2);
	// (undocumented)
	copyFile(
		source: CopySourceFile,
		destination: CopyDestination,
		options?: CopyFileOptions,
		traceContext?: MediaTraceContext,
	): Promise<MediaFile>;
	// (undocumented)
	downloadBinary(id: string, name?: string, collectionName?: string): Promise<void>;
	// (undocumented)
	getArtifactURL(
		artifacts: MediaFileArtifacts,
		artifactName: keyof MediaFileArtifacts,
		collectionName?: string,
	): Promise<string>;
	// (undocumented)
	getCurrentState(id: string, options?: GetFileOptions): Promise<FileState>;
	// (undocumented)
	getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
	// (undocumented)
	getFileState(id: string, options?: GetFileOptions): MediaSubscribable;
	// (undocumented)
	touchFiles(
		descriptors: TouchFileDescriptor[],
		collection?: string,
		traceContext?: MediaTraceContext,
	): Promise<TouchedFiles>;
	// (undocumented)
	upload(
		file: UploadableFile,
		controller?: UploadController,
		uploadableFileUpfrontIds?: UploadableFileUpfrontIds,
		traceContext?: MediaTraceContext,
	): MediaSubscribable;
	// (undocumented)
	uploadExternal(
		url: string,
		collection?: string,
		traceContext?: MediaTraceContext,
	): Promise<ExternalUploadPayload>;
}

// @public (undocumented)
export interface FileIdentifier {
	// (undocumented)
	readonly collectionName?: string;
	// (undocumented)
	readonly id: string;
	// (undocumented)
	readonly mediaItemType: 'file';
	// (undocumented)
	readonly occurrenceKey?: string;
}

// @public (undocumented)
export interface FileItem {
	// (undocumented)
	details: FileDetails;
	// (undocumented)
	type: 'file';
}

export { FilePreview };

// @public (undocumented)
export type FileProcessingStatus = 'failed' | 'pending' | 'running' | 'succeeded';

export { FileState };

// @public (undocumented)
export type FileStatus = FileStatus_2;

// @public (undocumented)
export function fromObservable(observable: ReplaySubject<FileState>): MediaSubscribable;

// @public (undocumented)
export const getArtifactUrl: (
	artifacts: MediaFileArtifacts,
	prop: keyof MediaFileArtifacts,
) => string | undefined;

// @public (undocumented)
export const getAttrsFromUrl: (blobUrl: string) => MediaBlobUrlAttrs | undefined;

// @public (undocumented)
export const getDimensionsFromBlob: (mediaType: MediaType, blob: Blob) => Promise<Dimensions>;

// @public (undocumented)
export interface GetFileOptions {
	// (undocumented)
	collectionName?: string;
	// (undocumented)
	occurrenceKey?: string;
	// (undocumented)
	preview?: PreviewOptions;
}

// @public (undocumented)
export const getFileStreamsCache: () => StreamsCache<FileState>;

// @public (undocumented)
export function getMediaClientErrorReason(err: Error): 'unknown' | MediaClientErrorReason;

// @public (undocumented)
export const getMediaEnvironment: () => string | undefined;

// @public (undocumented)
export const getMediaRegion: () => string | undefined;

// @public (undocumented)
export const globalMediaEventEmitter: {
	on<E extends keyof UploadEventPayloadMap>(
		event: E,
		listener: EventPayloadListener<UploadEventPayloadMap, E, any>,
	): void;
	off<E_1 extends keyof UploadEventPayloadMap>(
		event: E_1,
		listener: EventPayloadListener<UploadEventPayloadMap, E_1, any>,
	): void;
	emit<E_2 extends keyof UploadEventPayloadMap>(
		event: E_2,
		payload: UploadEventPayloadMap[E_2],
	): boolean | undefined;
};

// @public (undocumented)
export type Identifier = ExternalImageIdentifier | FileIdentifier;

// @public (undocumented)
export interface ImageMetadata {
	// (undocumented)
	original?: ImageMetadataArtifact;
	// (undocumented)
	pending: boolean;
	// (undocumented)
	preview?: ImageMetadataArtifact;
}

// @public (undocumented)
export type ImageMetadataArtifact = {
	url?: string;
	width?: number;
	height?: number;
	size?: number;
};

// @public (undocumented)
export type ImageResizeMode = 'crop' | 'fit' | 'full-fit' | 'stretchy-fit';

// @public (undocumented)
export const imageResizeModeToFileImageMode: (
	resizeMode?: ImageResizeMode,
) => MediaStoreGetFileImageParams['mode'];

// @public (undocumented)
export function isAbortedRequestError(err: any): boolean;

// @public (undocumented)
export const isDifferentIdentifier: (a: Identifier, b: Identifier) => boolean;

// @public (undocumented)
export const isErrorFileState: (fileState: FileState) => fileState is ErrorFileState;

// @public (undocumented)
export const isExternalImageIdentifier: (
	identifier: Identifier,
) => identifier is ExternalImageIdentifier;

// @public (undocumented)
export function isFileFetcherError(err: Error): err is FileFetcherError;

// @public (undocumented)
export const isFileIdentifier: (identifier: Identifier) => identifier is FileIdentifier;

// @public (undocumented)
export const isFinalFileState: (
	fileState: FileState,
) => fileState is ErrorFileState | ProcessedFileState | ProcessingFailedState;

// @public (undocumented)
export const isImageRepresentationReady: (fileState: FileState) => boolean;

// @public (undocumented)
export const isMediaBlobUrl: (url: string) => boolean;

// @public (undocumented)
export function isMediaClientError(error: any): error is MediaClientError<{
	reason: MediaClientErrorReason;
}>;

// @public (undocumented)
export function isMediaStoreError(err: Error): err is MediaStoreError;

// @public (undocumented)
export function isPollingError(err?: Error): err is PollingError;

// @public (undocumented)
export const isPreviewableFileState: (
	fileState: FileState,
) => fileState is (
	| ProcessedFileState
	| ProcessingFailedState
	| ProcessingFileState
	| UploadingFileState
) &
	PreviewableFileState;

// @public (undocumented)
export const isPreviewableType: (type: MediaType) => boolean;

// @public (undocumented)
export const isProcessedFileState: (fileState: FileState) => fileState is ProcessedFileState;

// @public (undocumented)
export const isProcessingFileState: (fileState: FileState) => fileState is ProcessingFileState;

// @public (undocumented)
export function isRateLimitedError(error: Error | undefined): boolean;

// @public (undocumented)
export function isRequestError(err: Error): err is RequestError;

// @public (undocumented)
export const isUploadingFileState: (fileState: FileState) => fileState is UploadingFileState;

// @public (undocumented)
export interface ItemsPayload {
	// (undocumented)
	items: ResponseFileItem[];
}

// @public (undocumented)
export const mapMediaFileToFileState: (mediaFile: MediaStoreResponse<MediaFile>) => FileState;

// @public (undocumented)
export const mapMediaItemToFileState: (id: string, item: MediaItemDetails) => FileState;

// @public (undocumented)
export const MAX_RESOLUTION = 4096;

// @public (undocumented)
interface MediaApi {
	// (undocumented)
	appendChunksToUpload: (
		uploadId: string,
		body: AppendChunksToUploadRequestBody,
		collectionName?: string,
		traceContext?: MediaTraceContext,
	) => Promise<void>;
	// (undocumented)
	copyFileWithToken: (
		body: MediaStoreCopyFileWithTokenBody,
		params: MediaStoreCopyFileWithTokenParams,
		traceContext?: MediaTraceContext,
	) => Promise<MediaStoreResponse<MediaFile>>;
	// (undocumented)
	createFileFromUpload: (
		body: MediaStoreCreateFileFromUploadBody,
		params: MediaStoreCreateFileFromUploadParams,
		traceContext?: MediaTraceContext,
	) => Promise<MediaStoreResponse<MediaFile>>;
	// (undocumented)
	createUpload: (
		createUpTo: number,
		collectionName?: string,
		traceContext?: MediaTraceContext,
	) => Promise<MediaStoreResponse<MediaUpload[]>>;
	// (undocumented)
	getArtifactURL: (
		artifacts: MediaFileArtifacts,
		artifactName: keyof MediaFileArtifacts,
		collectionName?: string,
	) => Promise<string>;
	// (undocumented)
	getFile: (
		fileId: string,
		params: MediaStoreGetFileParams,
		traceContext?: MediaTraceContext,
	) => Promise<MediaStoreResponse<MediaFile>>;
	// (undocumented)
	getFileBinaryURL: (id: string, collectionName?: string) => Promise<string>;
	// (undocumented)
	getFileImageURL: (id: string, params?: MediaStoreGetFileImageParams) => Promise<string>;
	// (undocumented)
	getFileImageURLSync: (id: string, params?: MediaStoreGetFileImageParams) => string;
	// (undocumented)
	getImage: (
		id: string,
		params?: MediaStoreGetFileImageParams,
		controller?: AbortController,
		fetchMaxRes?: boolean,
		traceContext?: MediaTraceContext,
	) => Promise<Blob>;
	// (undocumented)
	getImageMetadata: (
		id: string,
		params?: MediaStoreGetFileImageParams,
		traceContext?: MediaTraceContext,
	) => Promise<{
		metadata: ImageMetadata;
	}>;
	// (undocumented)
	getItems: (
		ids: string[],
		collectionName?: string,
		traceContext?: MediaTraceContext,
	) => Promise<MediaStoreResponse<ItemsPayload>>;
	// (undocumented)
	getRejectedResponseFromDescriptor: (
		descriptor: TouchFileDescriptor,
		limit: number,
	) => RejectedTouchFile;
	// (undocumented)
	probeChunks: (
		chunks: string[],
		uploadId: string,
		collectionName?: string,
		traceContext?: MediaTraceContext,
	) => Promise<MediaStoreResponse<MediaChunksProbe>>;
	// (undocumented)
	removeCollectionFile: (
		id: string,
		collectionName: string,
		occurrenceKey?: string,
		traceContext?: MediaTraceContext,
	) => Promise<void>;
	// (undocumented)
	request: (
		path: string,
		options: MediaStoreRequestOptions,
		controller?: AbortController,
	) => Promise<Response>;
	// (undocumented)
	resolveAuth: (authContext?: AuthContext) => Promise<Auth>;
	// (undocumented)
	resolveInitialAuth: () => Auth;
	// (undocumented)
	touchFiles: (
		body: MediaStoreTouchFileBody,
		params: MediaStoreTouchFileParams,
		traceContext?: MediaTraceContext,
	) => Promise<MediaStoreResponse<TouchedFiles>>;
	// (undocumented)
	uploadChunk: (
		etag: string,
		blob: Blob,
		uploadId: string,
		partNumber: number,
		collectionName?: string,
		traceContext?: MediaTraceContext,
	) => Promise<void>;
}

// @public (undocumented)
export interface MediaArtifact {
	// (undocumented)
	processingStatus?: FileProcessingStatus;
	// (undocumented)
	url?: string;
}

// @public (undocumented)
export interface MediaBlobUrlAttrs {
	// (undocumented)
	alt?: string;
	// (undocumented)
	collection?: string;
	// (undocumented)
	contextId: string;
	// (undocumented)
	height?: number;
	// (undocumented)
	id: string;
	// (undocumented)
	mimeType?: string;
	// (undocumented)
	name?: string;
	// (undocumented)
	size?: number;
	// (undocumented)
	width?: number;
}

// @public (undocumented)
export type MediaChunksProbe = {
	readonly results: {
		readonly [etag: string]: {
			readonly exists: boolean;
		};
	};
};

// @public (undocumented)
export class MediaClient {
	constructor(mediaClientConfig: MediaClientConfig, store?: MediaStore_2, mediaApi?: MediaStore);
	// @internal (undocumented)
	__DO_NOT_USE__getMediaStore(): MediaStore_2;
	// (undocumented)
	readonly config: MediaClientConfig;
	// (undocumented)
	emit<E extends keyof UploadEventPayloadMap>(event: E, payload: UploadEventPayloadMap[E]): boolean;
	// (undocumented)
	readonly file: FileFetcher;
	// (undocumented)
	getImage(
		id: string,
		params?: MediaStoreGetFileImageParams,
		controller?: AbortController,
		fetchMaxRes?: boolean,
		traceContext?: MediaTraceContext,
	): Promise<Blob>;
	// (undocumented)
	getImageMetadata(id: string, params?: MediaStoreGetFileImageParams): Promise<ImageMetadata>;
	// (undocumented)
	getImageUrl(id: string, params?: MediaStoreGetFileImageParams): Promise<string>;
	// (undocumented)
	getImageUrlSync(id: string, params?: MediaStoreGetFileImageParams): string;
	// (undocumented)
	readonly mediaClientConfig: MediaClientConfig;
	// (undocumented)
	readonly mediaStore: MediaStore;
	// (undocumented)
	mobileUploadPromise(): Promise<MobileUpload>;
	// (undocumented)
	off<E extends keyof UploadEventPayloadMap>(
		event: E,
		listener: EventPayloadListener<UploadEventPayloadMap, E>,
	): void;
	// (undocumented)
	on<E extends keyof UploadEventPayloadMap>(
		event: E,
		listener: EventPayloadListener<UploadEventPayloadMap, E>,
	): void;
	// (undocumented)
	removeFileFromCollection(
		id: string,
		collectionName: string,
		occurrenceKey?: string,
		traceContext?: MediaTraceContext,
	): Promise<void>;
	// (undocumented)
	readonly stargate: StargateClient;
}

export { MediaClientConfig };

// @public
export interface MediaClientError<Attributes extends MediaClientErrorAttributes> extends Error {
	// (undocumented)
	readonly attributes: Attributes;
}

// @public (undocumented)
export interface MediaClientErrorAttributes {
	// (undocumented)
	reason: MediaClientErrorReason;
}

// @public (undocumented)
export type MediaClientErrorReason =
	| 'authProviderTimedOut'
	| 'clientAbortedRequest'
	| 'clientOffline'
	| 'clientTimeoutRequest'
	| 'deprecatedEndpoint'
	| 'emptyAuth'
	| 'emptyFileName'
	| 'emptyItems'
	| 'failedAuthProvider'
	| 'fileSizeExceedsLimit'
	| 'invalidFileId'
	| 'missingInitialAuth'
	| 'pollingMaxAttemptsExceeded'
	| 'serverBadGateway'
	| 'serverBadRequest'
	| 'serverForbidden'
	| 'serverInternalError'
	| 'serverInvalidBody'
	| 'serverNotFound'
	| 'serverRateLimited'
	| 'serverUnauthorized'
	| 'serverUnexpectedError'
	| 'tokenExpired'
	| 'zeroVersionFile';

// @public (undocumented)
export type MediaFile = {
	readonly id: string;
	readonly mediaType: MediaType;
	readonly mimeType: string;
	readonly name: string;
	readonly processingStatus?: MediaFileProcessingStatus;
	readonly size: number;
	readonly artifacts: MediaFileArtifacts;
	readonly representations: MediaRepresentations;
	readonly createdAt?: number;
	readonly metadataTraceContext?: MediaTraceContext;
};

export { MediaFileArtifact };

export { MediaFileArtifacts };

// @public (undocumented)
export type MediaFileProcessingStatus = 'failed' | 'pending' | 'succeeded';

// @public (undocumented)
export type MediaItemDetails = {
	readonly mediaType: MediaType;
	readonly mimeType: string;
	readonly name: string;
	readonly processingStatus: MediaFileProcessingStatus;
	readonly size: number;
	readonly artifacts: MediaFileArtifacts;
	readonly representations: MediaRepresentations;
	readonly createdAt?: number;
	readonly metadataTraceContext?: MediaTraceContext;
};

// @public (undocumented)
export type MediaItemType = 'external-image' | 'file';

// @public (undocumented)
export type MediaObserver =
	| ((value: FileState) => void)
	| CompletionObserver
	| ErrorObserver
	| NextObserver;

// @public (undocumented)
export type MediaRepresentations = {
	image?: Object;
};

// @public (undocumented)
export class MediaStore implements MediaApi {
	constructor(config: MediaApiConfig);
	// (undocumented)
	appendChunksToUpload(
		uploadId: string,
		body: AppendChunksToUploadRequestBody,
		collectionName?: string,
		traceContext?: MediaTraceContext,
	): Promise<void>;
	// (undocumented)
	copyFileWithToken(
		body: MediaStoreCopyFileWithTokenBody,
		params: MediaStoreCopyFileWithTokenParams,
		traceContext?: MediaTraceContext,
	): Promise<MediaStoreResponse<MediaFile>>;
	// (undocumented)
	createFileFromUpload(
		body: MediaStoreCreateFileFromUploadBody,
		params?: MediaStoreCreateFileFromUploadParams,
		traceContext?: MediaTraceContext,
	): Promise<MediaStoreResponse<MediaFile>>;
	// (undocumented)
	createUpload(
		createUpTo?: number,
		collectionName?: string,
		traceContext?: MediaTraceContext,
	): Promise<MediaStoreResponse<MediaUpload[]>>;
	// (undocumented)
	getArtifactURL(
		artifacts: MediaFileArtifacts,
		artifactName: keyof MediaFileArtifacts,
		collectionName?: string,
	): Promise<string>;
	// (undocumented)
	getFile(
		fileId: string,
		params?: MediaStoreGetFileParams,
		traceContext?: MediaTraceContext,
	): Promise<MediaStoreResponse<MediaFile>>;
	// (undocumented)
	getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
	// (undocumented)
	getFileImageURL(id: string, params?: MediaStoreGetFileImageParams): Promise<string>;
	// (undocumented)
	getFileImageURLSync(id: string, params?: MediaStoreGetFileImageParams): string;
	// (undocumented)
	getImage(
		id: string,
		params?: MediaStoreGetFileImageParams,
		controller?: AbortController,
		fetchMaxRes?: boolean,
		traceContext?: MediaTraceContext,
	): Promise<Blob>;
	// (undocumented)
	getImageMetadata(
		id: string,
		params?: MediaStoreGetFileImageParams,
		traceContext?: MediaTraceContext,
	): Promise<{
		metadata: ImageMetadata;
	}>;
	// (undocumented)
	getItems(
		ids: string[],
		collectionName?: string,
		traceContext?: MediaTraceContext,
	): Promise<MediaStoreResponse<ItemsPayload>>;
	// (undocumented)
	getRejectedResponseFromDescriptor(
		descriptor: TouchFileDescriptor,
		limit: number,
	): RejectedTouchFile;
	// (undocumented)
	probeChunks(
		chunks: string[],
		uploadId: string,
		collectionName?: string,
		traceContext?: MediaTraceContext,
	): Promise<MediaStoreResponse<MediaChunksProbe>>;
	// (undocumented)
	removeCollectionFile(
		id: string,
		collectionName: string,
		occurrenceKey?: string,
		traceContext?: MediaTraceContext,
	): Promise<void>;
	// (undocumented)
	request(
		path: string,
		options?: MediaStoreRequestOptions,
		controller?: AbortController,
	): Promise<Response>;
	// (undocumented)
	resolveAuth: (authContext?: AuthContext) => Promise<Auth>;
	// (undocumented)
	resolveInitialAuth: () => Auth;
	// (undocumented)
	touchFiles(
		body: MediaStoreTouchFileBody,
		params?: MediaStoreTouchFileParams,
		traceContext?: MediaTraceContext,
	): Promise<MediaStoreResponse<TouchedFiles>>;
	// (undocumented)
	uploadChunk(
		etag: string,
		blob: Blob,
		uploadId: string,
		partNumber: number,
		collectionName?: string,
		traceContext?: MediaTraceContext,
	): Promise<void>;
}

// @public (undocumented)
export type MediaStoreCopyFileWithTokenBody = {
	sourceFile: SourceFile;
};

// @public (undocumented)
export type MediaStoreCopyFileWithTokenParams = {
	readonly collection?: string;
	readonly replaceFileId?: string;
	readonly occurrenceKey?: string;
};

// @public (undocumented)
export type MediaStoreCreateFileFromBinaryParams = {
	readonly replaceFileId?: string;
	readonly collection?: string;
	readonly occurrenceKey?: string;
	readonly expireAfter?: number;
	readonly skipConversions?: boolean;
	readonly name?: string;
};

// @public (undocumented)
export type MediaStoreCreateFileFromUploadBody = {
	readonly uploadId: string;
	readonly name?: string;
	readonly mimeType?: string;
	readonly conditions?: MediaStoreCreateFileFromUploadConditions;
};

// @public (undocumented)
export type MediaStoreCreateFileFromUploadConditions = {
	readonly hash?: string;
	readonly size?: number;
};

// @public (undocumented)
export type MediaStoreCreateFileFromUploadParams = {
	readonly collection?: string;
	readonly occurrenceKey?: string;
	readonly expireAfter?: number;
	readonly replaceFileId?: string;
	readonly skipConversions?: boolean;
};

// @public (undocumented)
export type MediaStoreCreateFileParams = {
	readonly occurrenceKey?: string;
	readonly collection?: string;
};

// @public (undocumented)
export class MediaStoreError extends BaseMediaClientError<MediaStoreErrorAttributes> {
	constructor(reason: MediaStoreErrorReason, innerError?: Error | undefined);
	// (undocumented)
	get attributes(): {
		reason: MediaStoreErrorReason;
		innerError: Error | undefined;
	};
	// (undocumented)
	readonly innerError?: Error | undefined;
	// (undocumented)
	readonly reason: MediaStoreErrorReason;
}

// @public (undocumented)
export type MediaStoreErrorAttributes = {
	readonly reason: MediaStoreErrorReason;
	readonly innerError?: Error;
};

// @public (undocumented)
export type MediaStoreErrorReason =
	| 'authProviderTimedOut'
	| 'emptyAuth'
	| 'failedAuthProvider'
	| 'missingInitialAuth'
	| 'tokenExpired';

// @public (undocumented)
export type MediaStoreGetFileImageParams = {
	readonly allowAnimated?: boolean;
	readonly version?: number;
	readonly collection?: string;
	readonly width?: number;
	readonly height?: number;
	readonly mode?: 'crop' | 'fit' | 'full-fit';
	readonly upscale?: boolean;
	readonly 'max-age'?: number;
};

// @public (undocumented)
export type MediaStoreGetFileParams = {
	readonly version?: number;
	readonly collection?: string;
};

// @public (undocumented)
export type MediaStoreRequestOptions = RequestMetadata & {
	readonly method?: RequestMethod;
	readonly authContext?: AuthContext;
	readonly params?: RequestParams;
	readonly headers?: RequestHeaders;
	readonly body?: any;
	readonly clientOptions?: ClientOptions;
	readonly traceContext?: MediaTraceContext;
};

// @public (undocumented)
export interface MediaStoreResponse<Data> {
	// (undocumented)
	readonly data: Data;
}

// @public (undocumented)
export interface MediaStoreTouchFileBody {
	// (undocumented)
	descriptors: TouchFileDescriptor[];
}

// @public (undocumented)
export interface MediaStoreTouchFileParams {
	// (undocumented)
	readonly collection?: string;
}

// @public (undocumented)
export type MediaSubscribable = {
	subscribe(observer?: MediaObserver): MediaSubscription;
};

// @public (undocumented)
export type MediaSubscription = {
	unsubscribe: () => void;
};

export { MediaType };

// @public (undocumented)
export type MediaUpload = {
	readonly id: string;
	readonly created: number;
	readonly expires: number;
};

// @public (undocumented)
export interface MediaViewedEventPayload {
	// (undocumented)
	fileId: string;
	// (undocumented)
	isUserCollection?: boolean;
	// (undocumented)
	viewingLevel: 'download' | 'full' | 'minimal';
}

// @public (undocumented)
export interface MobileUpload {
	// (undocumented)
	notifyUploadEnd(event: MobileUploadEndEvent): void;
	// (undocumented)
	notifyUploadError(event: MobileUploadErrorEvent): void;
	// (undocumented)
	notifyUploadProgress(event: MobileUploadProgressEvent): void;
	// (undocumented)
	notifyUploadStart(event: MobileUploadStartEvent): void;
}

// @public (undocumented)
export type MobileUploadEndEvent = {
	fileId: string;
};

// @public (undocumented)
export type MobileUploadErrorEvent = {
	fileId: string;
	message: string;
};

// @public (undocumented)
export type MobileUploadProgressEvent = {
	fileId: string;
	progress: number;
};

// @public (undocumented)
export type MobileUploadStartEvent = {
	fileId: string;
	collectionName?: string;
	occurrenceKey?: string;
	fileName: string;
	fileSize: number;
	fileMimetype: string;
	preview?: FilePreview;
	createdAt?: number;
};

// @public (undocumented)
type NextObserver = PartialObserver & Required<Pick<PartialObserver, 'next'>>;

// @public (undocumented)
export type NonErrorFileState = Exclude<FileState, ErrorFileState>;

// @public (undocumented)
export const objectToQueryString: (json: {
	[key: string]: boolean | null | number | string | undefined;
}) => string;

// @public (undocumented)
type PartialObserver = {
	next?: (value: FileState) => void;
	error?: (err: any) => void;
	complete?: () => void;
};

// @public (undocumented)
export class PollingError extends BaseMediaClientError<PollingErrorAttributes> {
	constructor(reason: PollingErrorReason, attempts: number);
	// (undocumented)
	readonly attempts: number;
	// (undocumented)
	get attributes(): {
		reason: 'pollingMaxAttemptsExceeded';
		attempts: number;
	};
	// (undocumented)
	readonly reason: PollingErrorReason;
}

// @public (undocumented)
export type PollingErrorAttributes = {
	readonly reason: PollingErrorReason;
	readonly attempts: number;
	readonly innerError?: Error;
};

// @public (undocumented)
export type PollingErrorReason = 'pollingMaxAttemptsExceeded';

// @public
export class PollingFunction {
	constructor(options?: Partial<PollingOptions>);
	// (undocumented)
	attempt: number;
	// (undocumented)
	cancel(): void;
	// (undocumented)
	execute(executor: Executor): Promise<void>;
	// (undocumented)
	getIntervalMsForIteration(iteration: number): number;
	// (undocumented)
	next(): void;
	// (undocumented)
	onError?: (error: Error) => void;
	// (undocumented)
	options: PollingOptions;
	// (undocumented)
	poll_intervalMs: number;
	// (undocumented)
	shouldIterate: boolean;
	// (undocumented)
	timeoutId: number;
}

// @public (undocumented)
interface PollingOptions {
	// (undocumented)
	poll_backoffFactor: number;
	// (undocumented)
	poll_intervalMs: number;
	// (undocumented)
	poll_maxAttempts: number;
	// (undocumented)
	poll_maxIntervalMs: number;
}

// @public (undocumented)
export interface PreviewableFileState {
	// (undocumented)
	preview: FilePreview | Promise<FilePreview>;
}

// @public (undocumented)
export interface PreviewOptions {}

export { ProcessedFileState };

export { ProcessingFailedState };

export { ProcessingFileState };

// @public (undocumented)
export const RECENTS_COLLECTION = 'recents';

// @public (undocumented)
interface RejectedTouchFile {
	// (undocumented)
	error: RejectionError;
	// (undocumented)
	fileId: string;
}

// @public (undocumented)
type RejectionError = {
	code: 'ExceedMaxFileSizeLimit';
	title: string;
	href: string;
	limit: number;
	size: number;
};

// @public (undocumented)
export function request(
	url: string,
	options?: RequestOptions,
	controller?: AbortController,
): Promise<Response>;

// @public (undocumented)
export class RequestError extends BaseMediaClientError<RequestErrorAttributes> {
	constructor(
		reason: RequestErrorReason,
		metadata?: RequestErrorMetadata | undefined,
		innerError?: Error | undefined,
	);
	// (undocumented)
	get attributes(): {
		reason: RequestErrorReason;
		method: RequestMethod | undefined;
		endpoint: string | undefined;
		mediaRegion: string | undefined;
		mediaEnv: string | undefined;
		attempts: number | undefined;
		clientExhaustedRetries: boolean | undefined;
		statusCode: number | undefined;
		innerError: Error | undefined;
	};
	// (undocumented)
	readonly innerError?: Error | undefined;
	// (undocumented)
	readonly metadata?: RequestErrorMetadata | undefined;
	// (undocumented)
	readonly reason: RequestErrorReason;
}

// @public (undocumented)
export type RequestErrorAttributes = RequestErrorMetadata & {
	readonly reason: RequestErrorReason;
};

// @public (undocumented)
export type RequestErrorMetadata = RequestMetadata & {
	readonly attempts?: number;
	readonly clientExhaustedRetries?: boolean;
	readonly statusCode?: number;
};

// @public (undocumented)
export type RequestErrorReason =
	| 'clientAbortedRequest'
	| 'clientOffline'
	| 'clientTimeoutRequest'
	| 'serverBadGateway'
	| 'serverBadRequest'
	| 'serverForbidden'
	| 'serverInternalError'
	| 'serverInvalidBody'
	| 'serverNotFound'
	| 'serverRateLimited'
	| 'serverUnauthorized'
	| 'serverUnexpectedError';

// @public (undocumented)
export type RequestHeaders = {
	[key: string]: string;
};

// @public (undocumented)
export type RequestMetadata = {
	readonly method?: RequestMethod;
	readonly endpoint?: string;
	readonly mediaRegion?: string;
	readonly mediaEnv?: string;
	readonly traceContext?: MediaTraceContext;
};

// @public (undocumented)
export type RequestMethod = 'DELETE' | 'GET' | 'POST' | 'PUT';

// @public (undocumented)
export type RequestOptions = RequestMetadata & {
	readonly auth?: Auth;
	readonly traceContext?: Required<MediaTraceContext>;
	readonly params?: RequestParams;
	readonly headers?: RequestHeaders;
	readonly body?: any;
	readonly clientOptions?: ClientOptions;
};

// @public (undocumented)
export type RequestParams = {
	[key: string]: any;
};

// @public (undocumented)
export interface ResponseFileItem {
	// (undocumented)
	collection?: string;
	// (undocumented)
	details: MediaItemDetails;
	// (undocumented)
	id: string;
	// (undocumented)
	metadataTraceContext?: MediaTraceContext;
	// (undocumented)
	type: 'file';
}

// @public (undocumented)
export type RetryOptions = {
	readonly startTimeoutInMs: number;
	readonly maxAttempts: number;
	readonly factor: number;
};

// @public (undocumented)
export interface SourceFile {
	// (undocumented)
	collection?: string;
	// (undocumented)
	id: string;
	// (undocumented)
	owner: AsapBasedAuth | ClientAltBasedAuth;
	// (undocumented)
	version?: number;
}

// @public (undocumented)
export class StargateClient {
	constructor(baseUrl: string | undefined);
	// (undocumented)
	fetchToken(clientId: string): Promise<EdgeData>;
	// (undocumented)
	isTokenExpired(token: EdgeData): boolean;
}

// @public (undocumented)
class StreamsCache<T> {
	constructor(streams: LRUMap<string, ReplaySubject<T>>);
	// (undocumented)
	get(id: string): ReplaySubject<T> | undefined;
	// (undocumented)
	getOrInsert(id: string, callback: () => ReplaySubject<T>): ReplaySubject<T>;
	// (undocumented)
	has(id: string): boolean;
	// (undocumented)
	remove(id: string): void;
	// (undocumented)
	removeAll(): void;
	// (undocumented)
	set(id: string, stream: ReplaySubject<T>): void;
	// (undocumented)
	get size(): number;
}

// @public (undocumented)
export type TouchedFiles = {
	created: CreatedTouchedFile[];
	rejected?: RejectedTouchFile[];
};

// @public (undocumented)
export interface TouchFileDescriptor {
	// (undocumented)
	collection?: string;
	// (undocumented)
	deletable?: boolean;
	// (undocumented)
	expireAfter?: number;
	// (undocumented)
	fileId: string;
	// (undocumented)
	occurrenceKey?: string;
	// (undocumented)
	size?: number;
}

// @public (undocumented)
export type UploadableFile = {
	content: ChunkinatorFile;
	name?: string;
	mimeType?: string;
	collection?: string;
	size?: number;
};

// @public (undocumented)
export type UploadableFileUpfrontIds = {
	id: string;
	deferredUploadId: Promise<string>;
	occurrenceKey?: string;
};

// @public (undocumented)
export class UploadController {
	constructor();
	// (undocumented)
	abort(): void;
	// (undocumented)
	abortFunction?: AbortFunction;
	// (undocumented)
	setAbort(abortFunction: AbortFunction): void;
}

// @public (undocumented)
export type UploadEventPayloadMap = {
	'file-added': FileState;
	'media-viewed': MediaViewedEventPayload;
};

// @public (undocumented)
export const uploadFile: (
	file: UploadableFile,
	store: MediaStore,
	uploadableFileUpfrontIds: UploadableFileUpfrontIds,
	callbacks?: UploadFileCallbacks,
	traceContext?: MediaTraceContext,
) => UploadFileResult;

// @public (undocumented)
export type UploadFileCallbacks = {
	onProgress: (progress: number) => void;
	onUploadFinish: (error?: any) => void;
};

// @public (undocumented)
export interface UploadFileResult {
	// (undocumented)
	cancel: () => void;
}

export { UploadingFileState };

// (No @packageDocumentation comment for this package)
```

<!--SECTION END: Main Entry Types-->

### Peer Dependencies

<!--SECTION START: Peer Dependencies-->

```json
{
	"@atlaskit/media-core": "^34.1.2",
	"@atlaskit/media-state": "^1.0.0"
}
```

<!--SECTION END: Peer Dependencies-->
